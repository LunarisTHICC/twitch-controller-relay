<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Twitch Controller Relay Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f1116;
      --panel: #151822;
      --text: #e6e6e6;
      --muted: #a3a3a3;
      --accent: #7c8cff;
      --ok: #44d19a;
      --warn: #f5a524;
      --bad: #ff5c5c;
      --border: #222633;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    header, footer {
      padding: 10px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    main {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 12px;
      padding: 12px;
    }
    #videoWrap {
      position: relative;
      background: #000;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      min-height: 240px;
    }
    video {
      width: 100%;
      height: auto;
      background: #000;
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      color: var(--muted);
      font-size: 14px;
      text-align: center;
      padding: 8px;
    }
    #pillbar {
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
    }
    .pill {
      padding: 6px 10px; border-radius: 999px; font-size: 12px;
      border: 1px solid var(--border); background: #0e1220; color: var(--muted);
    }
    .pill.ok { color: var(--ok); border-color: #224437; background: #15221d; }
    .pill.warn { color: var(--warn); border-color: #4a3b1a; background: #1a1711; }
    .pill.bad { color: var(--bad); border-color: #4a1f1f; background: #1a1111; }
    button, .btn {
      all: unset;
      display: inline-flex; align-items: center; justify-content: center;
      padding: 8px 12px; border-radius: 6px; cursor: pointer;
      border: 1px solid var(--border); background: #121626; color: var(--text);
      font-size: 13px;
    }
    button:hover { background: #182044; }
    #rightPanel {
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    #rightHeader {
      display: flex; align-items: center; justify-content: space-between;
      background: var(--panel); padding: 8px 10px;
    }
    #chatWrap { height: 480px; background: #0c0f18; border-top: 1px solid var(--border); }
    iframe { width: 100%; height: 100%; border: 0; background: #0c0f18; }
    #log {
      height: 180px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px; background: #0c0f18; border-top: 1px solid var(--border); padding: 8px;
      white-space: pre-wrap;
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #controls { display: flex; gap: 8px; flex-wrap: wrap; }
    #unmuteHint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <div class="row" id="pillbar">
      <span class="pill" id="pSig">Signaling</span>
      <span class="pill" id="pIce">ICE</span>
      <span class="pill" id="pDtls">DTLS</span>
      <span class="pill" id="pPc">Peer</span>
      <span class="pill" id="pDc">DC</span>
      <span class="pill" id="pAv">A/V</span>
      <span class="pill" id="pWs">WS</span>
      <span class="pill" id="pHost">Host</span>
      <span class="pill" id="pRelay">Relay</span>
    </div>
  </header>

  <main>
    <section id="videoPanel">
      <div class="row" id="controls">
        <button id="btnUnmute">Unmute</button>
        <button id="btnChat">Toggle chat</button>
        <button id="btnRemap">Toggle remap</button>
        <span id="unmuteHint">If muted, click Unmute to hear audio.</span>
      </div>
      <div id="videoWrap">
        <video id="vid" playsinline autoplay muted></video>
        <div id="overlay">
          <div id="ovText">Waiting for video frames…</div>
        </div>
      </div>
      <div id="log"></div>
    </section>

    <aside id="rightPanel">
      <div id="rightHeader">
        <div>Twitch chat</div>
        <div class="row">
          <label class="row" style="gap:4px;">
            <span class="pill">Channel:</span>
            <input id="chatChannel" placeholder="twitch channel" style="all:unset;border:1px solid var(--border);padding:4px 8px;border-radius:6px;background:#0e1220;color:var(--text);width:160px;" />
          </label>
          <button id="btnSetChannel">Set</button>
        </div>
      </div>
      <div id="chatWrap" hidden>
        <iframe id="chatIframe" referrerpolicy="no-referrer"></iframe>
      </div>
    </aside>
  </main>

  <footer>
    <span class="pill">Viewer</span>
    <span id="wsUrl" class="pill"></span>
  </footer>

<script>
(function(){
  const logEl = document.getElementById('log');
  const vid = document.getElementById('vid');
  const overlay = document.getElementById('overlay');
  const ovText = document.getElementById('ovText');
  const btnUnmute = document.getElementById('btnUnmute');
  const btnChat = document.getElementById('btnChat');
  const btnRemap = document.getElementById('btnRemap');
  const pSig = document.getElementById('pSig');
  const pIce = document.getElementById('pIce');
  const pDtls = document.getElementById('pDtls');
  const pPc = document.getElementById('pPc');
  const pDc = document.getElementById('pDc');
  const pAv = document.getElementById('pAv');
  const pWs = document.getElementById('pWs');
  const pHost = document.getElementById('pHost');
  const pRelay = document.getElementById('pRelay');
  const wsUrlPill = document.getElementById('wsUrl');
  const chatWrap = document.getElementById('chatWrap');
  const chatIframe = document.getElementById('chatIframe');
  const chatChannelInput = document.getElementById('chatChannel');
  const btnSetChannel = document.getElementById('btnSetChannel');

  const setPill = (el, state, label) => {
    el.classList.remove('ok','warn','bad');
    if (state === 'ok') el.classList.add('ok');
    else if (state === 'warn') el.classList.add('warn');
    else if (state === 'bad') el.classList.add('bad');
    if (label) el.textContent = label;
  };

  const log = (...args) => {
    const msg = args.join(' ');
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(msg);
  };

  // Hosting detection and relay derivation
  const u = new URL(window.location.href);
  const relayParam = u.searchParams.get('relay'); // required on GitHub Pages
  const pageHost = window.location.host;          // host actually serving this HTML
  const isHttps = window.location.protocol === 'https:';
  const wsProto = isHttps ? 'wss' : 'ws';

  // If ?relay is present, use it; otherwise, use page host (direct ngrok hosting)
  const relayHost = relayParam ? relayParam : pageHost;
  const wsUrl = `${wsProto}://${relayHost}/ws/viewer`;
  wsUrlPill.textContent = wsUrl;

  // Pills for host context
  setPill(pHost, 'ok', `Host ${pageHost}`);
  setPill(pRelay, relayParam ? 'ok' : 'warn', relayParam ? `Relay ${relayHost}` : `Relay derived ${relayHost}`);

  // Twitch chat setup: parent must match the page host exactly
  let chatChannel = u.searchParams.get('channel') || ''; // optional ?channel=
  chatChannelInput.value = chatChannel;

  const setChatSrc = () => {
    if (!chatChannel) {
      chatWrap.hidden = true;
      log('none chat');
      return;
    }
    const parent = pageHost; // exact current host
    const chatUrl = `https://www.twitch.tv/embed/${encodeURIComponent(chatChannel)}/chat?parent=${encodeURIComponent(parent)}`;
    chatIframe.src = chatUrl;
    chatWrap.hidden = false;
    log('block chat');
  };

  btnSetChannel.addEventListener('click', () => {
    chatChannel = chatChannelInput.value.trim();
    setChatSrc();
  });

  btnChat.addEventListener('click', () => {
    chatWrap.hidden = !chatWrap.hidden;
    log(chatWrap.hidden ? 'none chat' : 'block chat');
  });

  // Unmute handling
  btnUnmute.addEventListener('click', () => {
    vid.muted = false;
    vid.volume = 1.0;
    ovText.textContent = 'Playing…';
    log('Unmute clicked');
    vid.play().catch(e => log('Unmute play error:', e && e.message));
  });

  // WebRTC setup
  const pc = new RTCPeerConnection({
    // Keep defaults minimal; the relay provides ICE servers
  });

  let dc = null;

  pc.addEventListener('connectionstatechange', () => {
    const st = pc.connectionState;
    setPill(pPc, st === 'connected' ? 'ok' : (st === 'connecting' ? 'warn' : 'bad'), `Peer ${st}`);
    log(`Conn state ${st}`);
  });

  pc.addEventListener('iceconnectionstatechange', () => {
    const st = pc.iceConnectionState;
    setPill(pIce, st === 'connected' || st === 'completed' ? 'ok' : (st === 'checking' ? 'warn' : 'bad'), `ICE ${st}`);
    log(`ICE ${st}`);
  });

  pc.addEventListener('signalingstatechange', () => {
    const st = pc.signalingState;
    setPill(pSig, st === 'stable' ? 'ok' : 'warn', `Signaling ${st}`);
    log(`Signaling ${st}`);
  });

  pc.addEventListener('track', (ev) => {
    if (ev.track.kind === 'video') {
      const stream = ev.streams[0] || new MediaStream([ev.track]);
      vid.srcObject = stream;
      log('Track attached');
      setPill(pAv, 'warn', 'A/V track (waiting frames)');
    } else if (ev.track.kind === 'audio') {
      // Audio auto-plays once unmuted
      log('Audio track attached');
    }
  });

  pc.addEventListener('datachannel', (ev) => {
    dc = ev.channel;
    setPill(pDc, 'ok', 'DC open');
    log('DC open');
    dc.addEventListener('message', (m) => {
      // Viewer-side messages (e.g., pings, prompts)
      // No-op by default
    });
    dc.addEventListener('close', () => {
      setPill(pDc, 'bad', 'DC closed');
      log('DC closed');
    });
  });

  // Video health watchdog: reveals black-screen quickly
  let lastDecoded = 0;
  async function checkVideoStats() {
    try {
      const stats = await pc.getStats();
      stats.forEach(report => {
        if (report.type === 'inbound-rtp' && report.kind === 'video') {
          const decoded = report.framesDecoded || 0;
          const width = report.frameWidth || 0;
          const height = report.frameHeight || 0;
          const fr = report.framesPerSecond || 0;
          if (decoded > lastDecoded) {
            lastDecoded = decoded;
            overlay.style.display = 'none';
            setPill(pAv, 'ok', `Video ${width}x${height} @ ${fr || '?'}fps`);
          } else {
            overlay.style.display = 'grid';
            ovText.textContent = 'No new video frames (source stalled)…';
            setPill(pAv, 'warn', 'Video stalled');
          }
        }
      });
    } catch (e) {
      // ignore
    }
  }
  setInterval(checkVideoStats, 1000);

  // Establish WebSocket to relay
  const ws = new WebSocket(wsUrl);
  ws.addEventListener('open', () => {
    setPill(pWs, 'ok', 'WS open');
    log('WS open');
    // Identify as viewer
    ws.send(JSON.stringify({ role: 'viewer', hello: true }));
  });
  ws.addEventListener('close', () => {
    setPill(pWs, 'bad', 'WS closed');
    log('WS closed');
  });
  ws.addEventListener('error', (e) => {
    setPill(pWs, 'bad', 'WS error');
    log('WS error', e && e.message || '');
  });

  // Handle signaling messages
  ws.addEventListener('message', async (ev) => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch { return; }

    if (msg.type === 'welcome' && msg.viewer_id) {
      log(`Welcome ${msg.viewer_id}`);
    }

    if (msg.type === 'offer' && msg.sdp) {
      // Remote offer from streamer host
      await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: msg.sdp }));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ type: 'answer', sdp: pc.localDescription.sdp }));
      log('Answer applied');
    }

    if (msg.type === 'ice' && msg.candidate) {
      try {
        const cand = new RTCIceCandidate(msg.candidate);
        await pc.addIceCandidate(cand);
        log('ICE candidate added');
      } catch (e) {
        log('ICE add error', e && e.message || '');
      }
    }

    if (msg.type === 'config' && msg.channel) {
      // Optional channel push from server
      chatChannel = msg.channel;
      chatChannelInput.value = chatChannel;
      setChatSrc();
    }
  });

  // Send local ICE candidates to relay
  pc.addEventListener('icecandidate', (ev) => {
    if (ev.candidate) {
      ws.send(JSON.stringify({ type: 'ice', candidate: ev.candidate }));
      log('Sent ICE candidate');
    }
  });

  // Initial chat setup
  setChatSrc();

  // Simple gamepad polling (viewer-side input preview, not sending)
  let gpActive = false;
  function pollGamepad() {
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const any = pads && pads[0];
    if (any && !gpActive) {
      gpActive = true;
      log('GP connected');
    } else if (!any && gpActive) {
      gpActive = false;
      log('GP disconnected');
    }
  }
  setInterval(pollGamepad, 500);

  // Remap toggle (UI only — hook to DC if needed)
  let remapOn = false;
  btnRemap.addEventListener('click', () => {
    remapOn = !remapOn;
    btnRemap.textContent = remapOn ? 'Remap ON' : 'Toggle remap';
    log(remapOn ? 'Remap enabled' : 'Remap disabled');
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({ type: 'remap', enabled: remapOn }));
    }
  });

  // Autofocus play gesture improves autoplay on some browsers
  document.addEventListener('click', () => {
    vid.play().catch(()=>{});
  }, { once: true });
})();
</script>
</body>
</html>
