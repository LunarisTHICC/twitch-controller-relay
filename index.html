<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Oswald for intro, Montserrat/Orbitron for main UI -->
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Montserrat:wght@500;700&family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e0e10; --panel: #18181b; --edge: #23232a; --fg: #efeff1; --muted: #b9b9c2;
      --accent: #9146ff; --accent-2: #772ce8; --ok: #22c55e; --warn: #f59e0b; --bad: #ef4444;
      --chat-w: 360px; --banner-h: 44px;
      --header-h: 48px;
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      overscroll-behavior-y: none;
    }
    body { min-height: 100vh; }

    button, input, select, label { font-family: "Orbitron", system-ui, sans-serif; letter-spacing: 0.4px; }

    /* Banner */
    #brandBanner {
      position: relative;
      top: 0;
      z-index: 50;
      height: var(--banner-h);
      background: linear-gradient(90deg, rgba(12,10,22,.9), rgba(20,14,38,.9));
      border-bottom: 1px solid #241d3a;
      overflow: hidden;
      display: flex;
      align-items: center;
      width: 100%;
    }
    #brandTrack { display: flex; gap: 40px; align-items: center; white-space: nowrap; will-change: transform; animation: scrollX 26s linear infinite }
    #brandTrack .item{ font-family: "Orbitron",system-ui,sans-serif; font-size: 14px; letter-spacing: 1.4px; line-height: 1; color: #e9e2ff; text-shadow: 0 0 12px rgba(145,70,255,.55),0 0 2px rgba(145,70,255,.9);}
    .dot{display:inline-block;width:7px;height:7px;border-radius:50%;background:var(--accent);box-shadow:0 0 10px var(--accent)}
    @keyframes scrollX{0%{transform:translateX(0)}100%{transform:translateX(-50%)}}

    /* Debug header */
    header{display:flex;align-items:center;gap:8px;padding:8px 14px;background:#1f1f23;border-bottom:1px solid var(--edge);position:sticky;top:var(--banner-h);z-index:10;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;line-height:14px;background:#2a2a32;border:1px solid #3a3a4a;color:#cfd3df}
    .pill.ok{background:#15321f;border-color:#1e6a33;color:#a5e7b9}
    .pill.warn{background:#3a2a18;border-color:#b57a28;color:#ffd89a}
    .pill.bad{background:#3a1a1a;border-color:#b52828;color:#ff9a9a}
    #wsUrl{margin-left:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#9fb2d1}

    /* Layout */
    html, body {
      height: 100%;
      min-height: 100%;
    }
    body, #root {
      min-height: 100vh;
      width: 100%;
      margin: 0;
      padding: 0;
    }
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      padding: 12px;
      box-sizing: border-box;
      min-height: calc(100vh - var(--banner-h) - var(--header-h) - 60px);
    }
    body.chat-open #sidePanel{display:grid;}
    body.chat-open main{ grid-template-columns:1fr var(--chat-w); }

    /* Responsive Video */
    #videoWrap {
      position: relative;
      background: #0f1320;
      border: 1px solid #1d2436;
      border-radius: 8px;
      overflow: hidden;
      aspect-ratio: 16/9;
      min-height: 180px;
      max-height: calc(100vh - var(--banner-h) - var(--header-h) - 60px);
      height: 65vw;
      max-width: 100%;
      width: 100%;
      contain: layout paint;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 0 auto;
      box-sizing: border-box;
    }
    @media (max-width: 900px) {
      #videoWrap { height: 48vw; min-height: 140px; }
    }
    @media (max-width: 700px) {
      #videoWrap { height: 38vw; min-height: 90px; }
    }
    @media (max-width: 600px) {
      #videoWrap { height: 30vw; min-height: 60px; }
      main { padding: 5px; }
    }
    #vid { width: 100%; height: 100%; display: block; background: #000; object-fit: contain; aspect-ratio: inherit }
    #overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(10,14,21,.65),rgba(10,14,21,.75));pointer-events:none;transition:opacity .15s}
    #overlay[hidden]{display:none}
    #ovText{font-size:16px;color:#c6d3ea;text-shadow:0 1px 2px rgba(0,0,0,.6)}

    /* Controls */
	/* Remap dropdown */
	#controls { position: relative; }
	#btnRemap { /* same accent style already inherited, just keep id */ }
	#remapPanel {
	  position: absolute;
	  top: calc(100% + 8px);
	  left: 0;
	  min-width: 340px;
	  max-width: 92vw;
	  background: #0d1322;
	  color: #efeff1;
	  border: 1px solid #1d2436;
	  border-radius: 10px;
	  box-shadow: 0 8px 30px rgba(0,0,0,0.45);
	  padding: 12px;
	  z-index: 9000;
	}
	#remapPanel[hidden] { display: none; }
	#remapHeader {
	  display: flex; align-items: center; justify-content: space-between; gap: 10px;
	  padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #1d2436;
	}
	#remapHeader h3 {
	  margin: 0; font-size: 14px; font-weight: 700; letter-spacing: .6px; color: #cfd3df;
	  font-family: "Orbitron","Montserrat",system-ui,sans-serif;
	}
	#remapGrid {
	  display: grid; grid-template-columns: 120px 1fr; gap: 8px 10px; align-items: center;
	}
	#remapGrid label {
	  font-size: 12px; color: #b9b9c2; text-align: right; padding-right: 4px; user-select: none;
	}
	#remapGrid select {
	  border-radius: 8px; border: 1px solid #2a2a32; color: #f3edff; background: #1e123a;
	  padding: 6px 8px; font-size: 12px; width: 100%;
	}
	#remapFooter {
	  display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px;
	}
	#remapFooter button {
	  border-radius: 8px; border: 1px solid #2a2a32; background: #1e123a; color: #f3edff; padding: 6px 12px;
	}
	#remapFooter button.accent {
	  background: linear-gradient(180deg, var(--accent), var(--accent-2));
	  border-color: #5f37d6; color: #fff; box-shadow: 0 6px 18px rgba(145,70,255,.25), inset 0 0 0 1px rgba(255,255,255,.05)
	}

	/* Make sure Remap remains visible in "clean" mode */
	body.clean #controls > * { display: none; }
	body.clean #controls > #btnRemap { display: flex; }
	body.clean #controls > #btnChat,
	body.clean #controls > #volumeWrap,
	body.clean #controls > #btnFullscreen,
	body.clean #controls > #iconRow { display: flex; }
	/* Allow panel to show in clean mode when not hidden */
	body.clean #controls > #remapPanel:not([hidden]) { display: block; }
    #controls{display:flex;flex-wrap:wrap;gap:10px;padding:10px 0;align-items:center}
    button,input,select{border-radius:8px;border:1px solid #2a2a32;color:#f3edff;background:#1e123a}
    button.accent{background:linear-gradient(180deg,var(--accent),var(--accent-2));border-color:#5f37d6;color:#fff;box-shadow:0 6px 18px rgba(145,70,255,.25),inset 0 0 0 1px rgba(255,255,255,.05)}
    button.accent:hover{filter:brightness(1.05)} button.accent:active{transform:translateY(1px)}
    input[type=range]{appearance:none;height:6px;background:#1d1931;border:1px solid #2b2350;width:160px;border-radius:999px}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 0 8px rgba(145,70,255,.55);border:1px solid #fff1}

    /* Side panel */
    #sidePanel{display:none;grid-template-rows:min-content 1fr;gap:10px}
    #chatWrap {
      border: 1px solid #1d2436;
      border-radius: 8px;
      overflow: hidden;
      background: #0d1322;
      min-height: 320px;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-width: 200px;
      width: 100%;
    }
    #chatIframe {
      width: 100%;
      height: 100%;
      min-height: 320px;
      flex: 1 1 0;
      display: block;
      border: 0;
      background: #0d1322 !important;
      color-scheme: dark;
      color: #fff;
    }
    /* Force dark mode for Twitch chat iframe container */
    .twitch-dark-bg {
      background: #0d1322 !important;
      color-scheme: dark !important;
    }

    /* Logs (debugger) */
    #logPanel{display:grid;grid-template-rows:min-content 1fr;border:1px solid #1d2436;border-radius:8px;overflow:hidden}
    #logHeader{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:#121824;border-bottom:1px solid #1d2436}
    #log{margin:0;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.4;background:#0d1322;white-space:pre;overflow:auto}

    /* Footer */
    footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      color:#7a8fb2;
      border-top:1px solid #20283a;
      background:#0e1524
    }
    #footerNoticeWrap {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #footerNoticeWrap .footer-eye-btn {
      background: none;
      border: none;
      padding: 0;
      margin-right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: filter 0.2s;
    }
    #footerNoticeWrap .footer-eye-btn:hover {
      filter: drop-shadow(0 0 8px #9146ff);
      opacity: 0.9;
    }
    #footerNoticeText {
      font-size: 0.98em;
      color: #aeb6d3;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      letter-spacing: 0.04em;
    }
    #footerRight{margin-left:auto;display:flex;align-items:center;gap:8px}
    #btnDebugger{padding:6px 10px;font-size:12px;opacity:.9}

    /* Connection Lost Overlay */
    #lostConnectionOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(10,10,16,0.97);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #lostConnectionMsg {
      font-size: 1.5em;
      color: #fff;
      margin-bottom: 1em;
      text-align: center;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      text-shadow: 0 2px 18px #000;
    }
    #lostConnectionOverlay .footer-eye-btn {
      margin-bottom: 1em;
      filter: drop-shadow(0 0 4px #9146ff);
    }
    #reconnectBtn {
      background: linear-gradient(180deg,#9146ff,#772ce8);
      border: none;
      color: #fff;
      border-radius: 8px;
      padding: 0.5em 1.7em;
      font-size: 1.12em;
      font-family: 'Orbitron',sans-serif;
      cursor: pointer;
      letter-spacing: 0.06em;
      margin: 0 0.5em;
      box-shadow: 0 2px 14px #9146ff55;
      transition: background 0.15s;
    }
    #reconnectBtn:hover {
      background: linear-gradient(180deg,#a86afe,#a95cff);
      filter: brightness(1.08);
    }
    #reconnectCountdown {
      font-size: 1.12em;
      margin-top: 0.7em;
      color: #aeb6d3;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      letter-spacing: 0.04em;
    }
    /* Clean vs Debugger */
    body.clean header{display:none!important}
    body.clean #logPanel{display:none!important}
    body.clean #controls>*{display:none}
    body.clean #btnChat, body.clean #volumeWrap, body.clean #btnFullscreen, body.clean #iconRow{display:flex}
    body:not(.clean) #btnFullscreen{display:none}
    .fs-active #videoWrap{box-shadow:0 0 0 2px var(--accent) inset}

    /* --- Animated Intro Styles --- */
    #intro-overlay {
      position: fixed;
      inset: 0;
      background: black;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1s;
      opacity: 1;
      pointer-events: auto;
    }
    #eyes-container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      gap: 60px;
      position: relative;
      width: 340px;
      max-width: 90vw;
      margin: 0 auto;
    }
    .eye-wrap {
      transition: opacity 0.9s, transform 0.7s cubic-bezier(.8,2,.6,1);
      will-change: transform, opacity;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
    }
    .eye-wrap.visible {
      opacity: 1;
    }
    .eye-svg {
      width: 120px;
      height: 80px;
      display: block;
    }
    #intro-text {
      color: #e5e5e5;
      font-size: 3.0rem;
      font-family: 'Oswald', 'Arial Narrow', Arial, Helvetica, sans-serif;
      font-weight: 700;
      letter-spacing: 0.12em;
      opacity: 0;
      margin-top: 6px;
      background: none;
      transition: opacity 2s;
      text-align: center;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 4px rgba(0,0,0,0.18);
      text-transform: uppercase;
    }
    #intro-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    @media (max-width: 600px) {
      #eyes-container {
        min-height: 120px;
        gap: 24px;
        width: 160px;
      }
      .eye-svg {
        width: 68px;
        height: 48px;
      }
      #intro-text {
        font-size: 1.6rem;
        margin-top: 4px;
      }
    }
    /* --- End Animated Intro --- */
  </style>
</head>
<body class="clean">

  <!-- Animated HTML Intro Overlay -->
  <div id="intro-overlay">
    <div id="eyes-container"></div>
    <div id="intro-text">Doppelganger</div>
  </div>
  <!-- End Intro -->

  <div id="brandBanner" role="banner" aria-label="Credits banner"><div id="brandTrack"></div></div>

  <header>
    <span id="pRelay" class="pill">Relay</span><span id="pWs" class="pill">WS</span><span id="pSig" class="pill">Signaling</span><span id="pIce" class="pill">ICE</span><span id="pDtls" class="pill">DTLS</span><span id="pPc" class="pill">Peer</span><span id="pDc" class="pill">DC</span><span id="pAv" class="pill">A/V</span><span id="pTransport" class="pill">Transport</span>
    <span id="wsUrl" class="pill">ws://</span>
  </header>

  <main>
    <section>
      <div id="videoWrap">
        <video id="vid" playsinline muted autoplay></video>
        <div id="overlay"><div id="ovText">Connecting…</div></div>
      </div>
      <div id="controls">
		  <button id="btnRemap" class="accent" title="Remap controller buttons">Remap</button>
	<div id="remapPanel" hidden>
	  <div id="remapHeader">
		<h3>Viewer Control Remap</h3>
		<div style="font-size:11px;color:#9aa7c8;opacity:.9">Maps your physical button → virtual button sent to host</div>
	  </div>
	  <div id="remapGrid"></div>
	  <div id="remapFooter">
		<button id="btnRemapReset">Reset</button>
		<button id="btnRemapClose" class="accent">Close</button>
	  </div>
	</div>
        <button id="btnChat" class="accent" title="Toggle Twitch chat">Twitch Chat</button>

        <div id="volumeWrap" style="display:flex;align-items:center;gap:8px">
          <label for="vol" style="opacity:.8">Volume</label>
          <input id="vol" type="range" min="0" max="100" value="0" />
          <div id="iconRow">
            <button id="btnMute" class="muted" aria-label="Toggle mute" title="Toggle audio">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 10v4h4l5 4V6L7 10H3z"></path>
                <path d="M14.5 12a4.5 4.5 0 0 0-1.2-3.1l1.4-1.4A6.5 6.5 0 0 1 16.5 12a6.5 6.5 0 0 1-1.8 4.5l-1.4-1.4A4.5 4.5 0 0 0 14.5 12z"></path>
                <path d="M18 12a8 8 0 0 0-2.1-5.4l1.4-1.4A10 10 0 0 1 20 12a10 10 0 0 1-2.7 6.8l-1.4-1.4A8 8 0 0 0 18 12z"></path>
              </svg>
            </button>
            <div id="padIconWrap" class="off" title="Controller status">
              <svg id="padIcon" class="off" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 8h10a4 4 0 0 1 3.8 2.7l1.1 3.2A3 3 0 0 1 19 18h-1.7l-1.8-2H8.5l-1.8 2H5A3 3 0 0 1 2.1 13.9l1.1-3.2A4 4 0 0 1 7 8zm3 2H8v2H6v2h2v2h2v-2h2v-2h-2v-2zm8 1.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
              </svg>
            </div>
          </div>
        </div>

        <button id="btnFullscreen" class="accent" title="Fullscreen">Fullscreen</button>
        <button id="btnDownloadLogs">Download logs</button>
      </div>
    </section>

    <aside id="sidePanel">
      <div id="chatWrap" hidden><iframe id="chatIframe" title="Twitch chat"></iframe></div>
      <div id="logPanel"><div id="logHeader"><strong>Viewer logs</strong><span style="opacity:.7">Use “Download logs”.</span></div><pre id="log"></pre></div>
    </aside>
  </main>

  <footer>
    <div id="footerNoticeWrap">
      <button class="footer-eye-btn" tabindex="-1" aria-label="Animated Eye" style="background:none;border:none;outline:none;padding:0;">
        <svg class="eye-svg" viewBox="0 0 120 80" width="34" height="24">
          <ellipse class="eyeball" cx="60" cy="40" rx="28" ry="18" stroke="#e5e5e5" stroke-width="3" fill="#181818"/>
          <ellipse class="iris" cx="60" cy="40" rx="10" ry="10" fill="#e5e5e5"/>
          <ellipse class="pupil" cx="60" cy="40" rx="5" ry="5" fill="#1a1a1a"/>
        </svg>
      </button>
      <span id="footerNoticeText">Not affiliated by Twitch and all code complies with ToS.</span>
    </div>
    <div id="footerRight"><button id="btnDebugger" title="Toggle debug UI">Debugger</button></div>
  </footer>

  <!-- Scripts: Animated Intro (runs first), then Viewer scripts -->
  <script>
    // --- Animated Intro JS ---
    // Use #e5e5e5 for all "white" lines (10% darker than #fff)
    function getEyeSVG(rx = 50, ry = 30, pupilDx = 0, pupilDy = 0, eyelidOpacity = 0) {
      return `
<svg class="eye-svg" viewBox="0 0 120 80" fill="none">
  <ellipse class="eyeball" cx="60" cy="40" rx="${rx}" ry="${ry}" stroke="#e5e5e5" stroke-width="4" fill="#181818"/>
  <ellipse class="iris" cx="${60 + pupilDx}" cy="${40 + pupilDy}" rx="18" ry="18" fill="#e5e5e5"/>
  <ellipse class="pupil" cx="${60 + pupilDx}" cy="${40 + pupilDy}" rx="8" ry="8" fill="#1a1a1a"/>
  <ellipse class="eyelid" cx="60" cy="40" rx="${rx}" ry="${ry}" fill="black" style="opacity:${eyelidOpacity};"/>
</svg>
      `;
    }

    const overlayIntro = document.getElementById('intro-overlay');
    const eyesContainer = document.getElementById('eyes-container');
    const introText = document.getElementById('intro-text');
    let animationSkipped = false;
    let skipTimeout;

    function animateEyeShape(eye, opts, duration = 400) {
      const eyeball = eye.querySelector('.eyeball');
      const iris = eye.querySelector('.iris');
      const pupil = eye.querySelector('.pupil');
      let start = null;
      const rx0 = +eyeball.getAttribute('rx');
      const ry0 = +eyeball.getAttribute('ry');
      const irisCx0 = +iris.getAttribute('cx');
      const irisCy0 = +iris.getAttribute('cy');
      const pupilCx0 = +pupil.getAttribute('cx');
      const pupilCy0 = +pupil.getAttribute('cy');
      const rx1 = opts.rx;
      const ry1 = opts.ry;
      const irisCx1 = 60 + opts.pupilDx;
      const irisCy1 = 40 + opts.pupilDy;
      const pupilCx1 = 60 + opts.pupilDx;
      const pupilCy1 = 40 + opts.pupilDy;

      function stepEye(ts) {
        if (!start) start = ts;
        let t = Math.min(1, (ts - start)/duration);
        t = t<0.5 ? 4*t*t*t : 1-(-2*t+2)**3/2;
        eyeball.setAttribute('rx', rx0 + (rx1 - rx0)*t);
        eyeball.setAttribute('ry', ry0 + (ry1 - ry0)*t);
        iris.setAttribute('cx', irisCx0 + (irisCx1 - irisCx0)*t);
        iris.setAttribute('cy', irisCy0 + (irisCy1 - irisCy0)*t);
        pupil.setAttribute('cx', pupilCx0 + (pupilCx1 - pupilCx0)*t);
        pupil.setAttribute('cy', pupilCy0 + (pupilCy1 - pupilCy0)*t);
        const eyelid = eye.querySelector('.eyelid');
        eyelid.setAttribute('rx', rx0 + (rx1 - rx0)*t);
        eyelid.setAttribute('ry', ry0 + (ry1 - ry0)*t);
        if (t < 1) requestAnimationFrame(stepEye);
      }
      requestAnimationFrame(stepEye);
    }

    function setBlink(eye, closed, duration = 200) {
      const eyelid = eye.querySelector('.eyelid');
      eyelid.style.transition = `opacity ${duration}ms`;
      eyelid.style.opacity = closed ? 1 : 0;
    }
    function widenEye(eye, widened = true) {
      const eyeball = eye.querySelector('.eyeball');
      const eyelid = eye.querySelector('.eyelid');
      const targetRy = widened ? 38 : 30;
      eyeball.setAttribute('ry', targetRy);
      eyelid.setAttribute('ry', targetRy);
    }

    function fadeInEyeWrap(eyeWrap, duration = 900, cb) {
      eyeWrap.style.transition = `opacity ${duration}ms`;
      setTimeout(() => {
        eyeWrap.style.opacity = 1;
        if (typeof cb === "function") setTimeout(cb, duration);
      }, 20);
    }

    function fadeOut(element, duration = 800) {
      element.style.opacity = 0;
      element.style.transition = `opacity ${duration}ms`;
    }

    function fadeIn(element, duration = 2000) {
      element.style.opacity = 1;
      element.style.transition = `opacity ${duration}ms`;
    }

    function animateIntro() {
      eyesContainer.innerHTML = '';
      introText.style.opacity = 0;
      introText.style.backgroundPosition = 'left';

      const eyeForward = {rx:50, ry:30, pupilDx:0, pupilDy:0};
      const eyeTurnLeft = {rx:40, ry:33, pupilDx:-23, pupilDy:2};
      const eyeTurnRight = {rx:40, ry:33, pupilDx:23, pupilDy:2};
      const leftStartOffset = 40;
      const leftEndOffset = 0;

      // Create left eye wrap, opacity 0 for fade-in, start closer to center for smooth slide
      const leftEyeWrap = document.createElement('div');
      leftEyeWrap.className = 'eye-wrap';
      leftEyeWrap.style.opacity = 0;
      leftEyeWrap.style.transform = `translateX(${leftStartOffset}px)`;
      leftEyeWrap.innerHTML = getEyeSVG(eyeForward.rx, eyeForward.ry, eyeForward.pupilDx, eyeForward.pupilDy, 0);
      eyesContainer.appendChild(leftEyeWrap);

      fadeInEyeWrap(leftEyeWrap, 900, () => {
        if (animationSkipped) return skipToEnd();
        setBlink(leftEyeWrap.firstElementChild, true, 120);
        setTimeout(() => setBlink(leftEyeWrap.firstElementChild, false, 160), 180);

        // After a second, fade in right eye and slide left eye smoothly
        setTimeout(() => {
          if (animationSkipped) return skipToEnd();
          const rightEyeWrap = document.createElement('div');
          rightEyeWrap.className = 'eye-wrap';
          rightEyeWrap.style.opacity = 0;
          rightEyeWrap.innerHTML = getEyeSVG(eyeForward.rx, eyeForward.ry, eyeForward.pupilDx, eyeForward.pupilDy, 0);

          eyesContainer.appendChild(rightEyeWrap);

          // The fix: trigger both transitions in the same frame, using fadeInEyeWrap for right eye
          requestAnimationFrame(() => {
            leftEyeWrap.style.transition = 'transform 0.7s cubic-bezier(.8,2,.6,1), opacity 0.7s';
            leftEyeWrap.style.transform = `translateX(${leftEndOffset}px)`;
            fadeInEyeWrap(rightEyeWrap, 900);
          });

          setTimeout(() => {
            if (animationSkipped) return skipToEnd();
            animateEyeShape(leftEyeWrap.firstElementChild, eyeTurnRight, 400);
            animateEyeShape(rightEyeWrap.firstElementChild, eyeTurnLeft, 400);
            widenEye(leftEyeWrap.firstElementChild, true);
          }, 700);

          setTimeout(() => {
            if (animationSkipped) return skipToEnd();
            setBlink(leftEyeWrap.firstElementChild, true, 80);
            setBlink(rightEyeWrap.firstElementChild, true, 80);
            setTimeout(() => {
              setBlink(leftEyeWrap.firstElementChild, false, 100);
              setBlink(rightEyeWrap.firstElementChild, false, 100);

              setTimeout(() => {
                setBlink(leftEyeWrap.firstElementChild, true, 80);
                setBlink(rightEyeWrap.firstElementChild, true, 80);

                setTimeout(() => {
                  setBlink(leftEyeWrap.firstElementChild, false, 100);
                  setBlink(rightEyeWrap.firstElementChild, false, 100);

                  setTimeout(() => {
                    animateEyeShape(leftEyeWrap.firstElementChild, eyeForward, 350);
                    animateEyeShape(rightEyeWrap.firstElementChild, eyeForward, 350);
                    widenEye(leftEyeWrap.firstElementChild, false);

                    setTimeout(() => {
                      if (animationSkipped) return skipToEnd();
                      fadeIn(introText, 2000);
                      introText.style.backgroundPosition = 'right';
                      setTimeout(() => {
                        fadeOut(leftEyeWrap, 600);
                        fadeOut(rightEyeWrap, 600);
                        fadeOut(introText, 600);
                        setTimeout(() => fadeOut(overlayIntro, 800), 600);
                      }, 1300);
                    }, 380);
                  }, 350);
                }, 180);
              }, 160);
            }, 110);
          }, 900);
        }, 1100);
      });

      skipTimeout = setTimeout(() => fadeOut(overlayIntro, 900), 10100);
    }

    function skipToEnd() {
      if (animationSkipped) return;
      animationSkipped = true;
      clearTimeout(skipTimeout);
      fadeOut(overlayIntro, 700);
    }

    function setupSkip() {
      let lastClick = 0, clickCount = 0, lastKey = 0, keyCount = 0;
      overlayIntro.addEventListener('click', () => {
        const now = Date.now();
        if (now - lastClick < 400) clickCount++;
        else clickCount = 1;
        lastClick = now;
        if (clickCount >= 2) skipToEnd();
      });
      window.addEventListener('keydown', (e) => {
        const now = Date.now();
        if (now - lastKey < 400) keyCount++;
        else keyCount = 1;
        lastKey = now;
        if (keyCount >= 2) skipToEnd();
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      animateIntro();
      setupSkip();
      overlayIntro.addEventListener('transitionend', () => {
        if (overlayIntro.style.opacity === '0') overlayIntro.style.display = 'none';
      });
    });
  </script>
  <script>
    // --- Viewer.html JS: all original code below, with connection lost overlay logic added ---

    const logEl=document.getElementById('log'); function log(m){const t=new Date().toLocaleTimeString(); logEl.textContent+=`[${t}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight;}
    function pill(id,cls,text){const el=document.getElementById(id); if(!el) return; el.className='pill '+(cls||''); if(text) el.textContent=text;}

    // ----- Banner with meta fallbacks -----
    // NOTE: Banner stats are now static per user request!
    const PROJECT_START = new Date('2025-09-29T00:00:00Z');
    const brandTrack = document.getElementById('brandTrack');
    function item(text){ const s=document.createElement('span'); s.className='item'; const d1=document.createElement('i'); d1.className='dot'; const d2=document.createElement('i'); d2.className='dot'; s.appendChild(d1); s.appendChild(document.createTextNode(' ')); s.appendChild(document.createTextNode(text)); s.appendChild(document.createTextNode(' ')); s.appendChild(d2); return s; }
    async function buildBanner(){
      brandTrack.innerHTML='';
      // Static stats per user request
      const now=new Date(); 
      // Local time string formatted as HH:MM (24hr)
      const hh=String(now.getHours()).padStart(2,'0'), mm=String(now.getMinutes()).padStart(2,'0');
      const days=Math.max(1, Math.floor((now-PROJECT_START)/86400000));
      const texts = [
        `Local time: ${hh}:${mm}`,
        `Viewer mode: ${document.body.classList.contains('clean') ? 'Clean' : 'Debugger'}`,
        `Made by JunkfoodJon with CoPilot and GitHub`,
        `How long this project took: ${days} day${days!==1?'s':''}`,
        `Lines of code used: 1984+`,
        `Languages used: Python, HTML, CSS, JavaScript`,
        `Models used: Gpt-5 & GPT-4.`
      ];
      const frag=document.createDocumentFragment();
      for(let k=0;k<2;k++){ texts.forEach(t=>frag.appendChild(item(t))); }
      brandTrack.appendChild(frag);
    }

    // ----- Chat (force junkfoodjon, dark) -----
    const chatWrap=document.getElementById('chatWrap'), chatIframe=document.getElementById('chatIframe');
    function setChatSrc(){
      const parent=location.hostname; // Twitch requires hostname, not host/port
      const ch='junkfoodjon';
      // Twitch dark mode, allow iframe to fill entire chatWrap flexbox area
      // The "dark" param is necessary but Twitch may still use system color scheme, so force dark on wrapper
      chatIframe.src=`https://www.twitch.tv/embed/${encodeURIComponent(ch)}/chat?parent=${parent}&theme=dark`;
      chatIframe.classList.add('twitch-dark-bg');
      chatIframe.style.background='#0d1322';
      chatIframe.style.height='100%';
      chatIframe.style.width='100%';
      chatIframe.style.display='block';
      chatIframe.allowTransparency='true';
    }
    function toggleChat(){ 
      const open=!document.body.classList.contains('chat-open'); 
      if(open){ 
        document.body.classList.add('chat-open'); 
        chatWrap.hidden=false;
        // Ensure chat scales vertically on open
        chatWrap.style.height = '100%';
        chatIframe.style.height = '100%';
      } else { 
        document.body.classList.remove('chat-open'); 
        chatWrap.hidden=true; 
      } 
    }
    document.getElementById('btnChat').onclick=toggleChat;
		// ----- Remap UI + state -----
	const ALL_BUTTONS = ["A","B","X","Y","LB","RB","Back","Start","LS","RS","DPadUp","DPadDown","DPadLeft","DPadRight"];
	const DISABLE_SENTINEL = ""; // maps to "send nothing"
	const REMAP_STORE_KEY = "controlRemapV1";

	function defaultRemap() {
	  const m = {};
	  ALL_BUTTONS.forEach(n => m[n] = n);
	  return m;
	}
	function loadRemap() {
	  try {
		const raw = localStorage.getItem(REMAP_STORE_KEY);
		if (!raw) return defaultRemap();
		const obj = JSON.parse(raw);
		// sanity: ensure all keys exist
		ALL_BUTTONS.forEach(n => { if (!(n in obj)) obj[n] = n; });
		return obj;
	  } catch { return defaultRemap(); }
	}
	function saveRemap(m) {
	  try { localStorage.setItem(REMAP_STORE_KEY, JSON.stringify(m)); } catch {}
	}
	let remap = loadRemap();

	const btnRemap = document.getElementById('btnRemap');
	const remapPanel = document.getElementById('remapPanel');
	const remapGrid = document.getElementById('remapGrid');
	const btnRemapReset = document.getElementById('btnRemapReset');
	const btnRemapClose = document.getElementById('btnRemapClose');

	function buildRemapPanel() {
	  remapGrid.innerHTML = "";
	  ALL_BUTTONS.forEach(src => {
		const lab = document.createElement('label');
		lab.textContent = src;
		const sel = document.createElement('select');

		// Disabled option
		const optDis = document.createElement('option');
		optDis.value = DISABLE_SENTINEL;
		optDis.textContent = "(Disabled)";
		sel.appendChild(optDis);

		// Options for all virtual targets
		ALL_BUTTONS.forEach(dst => {
		  const opt = document.createElement('option');
		  opt.value = dst;
		  opt.textContent = dst;
		  sel.appendChild(opt);
		});

		sel.value = (remap[src] ?? src);
		sel.onchange = () => {
		  remap[src] = sel.value;
		  saveRemap(remap);
		  log(`[REMAP] ${src} -> ${sel.value || "(Disabled)"}`);
		};

		remapGrid.appendChild(lab);
		remapGrid.appendChild(sel);
	  });
	}

	function toggleRemapPanel() {
	  const willShow = remapPanel.hasAttribute('hidden');
	  if (willShow) buildRemapPanel();
	  if (willShow) remapPanel.removeAttribute('hidden'); else remapPanel.setAttribute('hidden', "");
	}

	btnRemap.onclick = toggleRemapPanel;
	btnRemapReset.onclick = () => {
	  remap = defaultRemap();
	  saveRemap(remap);
	  buildRemapPanel();
	  log("[REMAP] Reset to defaults");
	};
	btnRemapClose.onclick = () => remapPanel.setAttribute('hidden', "");

	// Close when clicking outside
	document.addEventListener('click', (e) => {
	  if (!remapPanel.hasAttribute('hidden')) {
		const within = remapPanel.contains(e.target) || btnRemap.contains(e.target);
		if (!within) remapPanel.setAttribute('hidden', "");
	  }
	});

    // ----- Video / audio -----
    const vid=document.getElementById('vid'), vol=document.getElementById('vol'), btnMute=document.getElementById('btnMute');
    const overlay=document.getElementById('overlay'), ovText=document.getElementById('ovText'), videoWrap=document.getElementById('videoWrap');

    function ensurePlay(){ const p=vid.play(); if(p&&p.then)p.catch(()=>{}); }
    function updateMuteVisual(){ const muted=vid.muted||vid.volume===0; btnMute.classList.toggle('muted',muted); btnMute.setAttribute('aria-pressed', String(!muted)); }
    function lockAspectFromTrack(track){ try{ const st = track.getSettings?.()||{}; const w = st.width||0, h=st.height||0; if(w>0 && h>0) videoWrap.style.aspectRatio = `${w} / ${h}`; }catch{} }

    let autoUnmuted = false;
    async function firstInteract(){ if(autoUnmuted) return; autoUnmuted = true; try{ const stored = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'30',10))); if(vid.volume===0&&stored>0){ vid.volume=stored/100; vol.value=stored; } vid.muted=false; updateMuteVisual(); ensurePlay(); }catch{} }
    ['pointerdown','keydown'].forEach(ev=>window.addEventListener(ev, firstInteract, {once:true, capture:true}));

    btnMute.onclick=async()=>{ try{ if(vid.muted || vid.volume===0){ vid.muted=false; if (vid.volume===0) { const stored=Math.max(0,Math.min(100,parseInt(localStorage.getItem('viewerVolume')||'30',10)||30)); vid.volume=stored/100; vol.value=stored; } }else{ vid.muted=true; } updateMuteVisual(); ensurePlay(); }catch{} };
    vol.addEventListener('input', ()=>{ const v=Math.max(0,Math.min(100,parseInt(vol.value||'0',10)))/100; vid.volume=v; localStorage.setItem('viewerVolume', String(Math.round(v*100))); if(v>0) vid.muted=false; updateMuteVisual(); ensurePlay(); });
    const initVol = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'0',10))); vol.value = initVol; vid.volume = initVol/100; if(initVol===0) vid.muted=true; updateMuteVisual();

    // Fullscreen
    function toggleFs(){ if(!document.fullscreenElement){ (videoWrap.requestFullscreen||videoWrap.webkitRequestFullscreen||videoWrap.msRequestFullscreen||document.body.requestFullscreen||function(){})?.call(videoWrap); } else { (document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen||function(){})?.call(document); } }
    document.getElementById('btnFullscreen').onclick=toggleFs;
    videoWrap.ondblclick=toggleFs;
    document.addEventListener('fullscreenchange', ()=>{ document.body.classList.toggle('fs-active', !!document.fullscreenElement); });

    document.getElementById('btnDebugger').onclick=()=>{ document.body.classList.toggle('clean'); buildBanner(); };

    // ----- Connection -----
    const params=new URLSearchParams(location.search);
    const relayHost=(params.get('relay')||location.host).replace(/^https?:\/\//,'').replace(/\/+$/,'');
    const wsUrl=`${location.protocol==='https:'?'wss':'ws'}://${relayHost}/ws/viewer`;
    document.getElementById('wsUrl').textContent=wsUrl;
    pill('pRelay','ok','Relay: '+relayHost); pill('pTransport','ok','Transport: WebRTC');

    let pc, ws, dc, viewerID=null, restarting=false, hbTimer=null, stallTimer=null;
    let retryDelay = 700;
    const inbound=new MediaStream();

    // --- Connection lost/reconnect overlay logic ---
    let isDisconnected = false;
    function handleDisconnect(reason) {
      if (isDisconnected) return;
      isDisconnected = true;
      log("[CONNECTION LOST] " + reason);
      // Remove any old overlay
      if (document.getElementById('lostConnectionOverlay')) {
        document.getElementById('lostConnectionOverlay').remove();
      }
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'lostConnectionOverlay';
      overlay.innerHTML = `
        <button class="footer-eye-btn" tabindex="-1" aria-label="Animated Eye" style="margin-bottom:1.4em;">
          <svg class="eye-svg" viewBox="0 0 120 80" width="54" height="38">
            <ellipse class="eyeball" cx="60" cy="40" rx="28" ry="18" stroke="#e5e5e5" stroke-width="3" fill="#181818"/>
            <ellipse class="iris" cx="60" cy="40" rx="10" ry="10" fill="#e5e5e5"/>
            <ellipse class="pupil" cx="60" cy="40" rx="5" ry="5" fill="#1a1a1a"/>
          </svg>
        </button>
        <div id="lostConnectionMsg">
          Connection to stream host lost.<br>
          Please reload or <button id="reconnectBtn">Reconnect</button>
        </div>
        <div id="reconnectCountdown">Auto-reloading in <span id="reconnectCount">5</span> seconds...</div>
      `;
      document.body.appendChild(overlay);
      let seconds = 5;
      const countdownEl = document.getElementById('reconnectCount');
      const timer = setInterval(() => {
        seconds--;
        if (countdownEl) countdownEl.textContent = seconds;
        if (seconds <= 0) {
          clearInterval(timer);
          location.reload();
        }
      }, 1000);
      document.getElementById('reconnectBtn').onclick = () => location.reload();
    }

    // --- End overlay logic ---

    function startViewer(){
      log('WS URL → '+wsUrl); pill('pWs','','WS: connecting'); showOverlay('Connecting…');

      pc=new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478']}], bundlePolicy:'max-bundle'});
      const vTrans=pc.addTransceiver('video',{direction:'recvonly'}); pc.addTransceiver('audio',{direction:'recvonly'});

      try{
        const caps=RTCRtpReceiver.getCapabilities('video'); const codecs=(caps&&caps.codecs)||[];
        const h264=codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('h264'));
        const vp8 =codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('vp8'));
        const prefs=[...h264,...vp8];
        if(vTrans&&vTrans.setCodecPreferences&&prefs.length){ vTrans.setCodecPreferences(prefs); }
      }catch{}

      dc=pc.createDataChannel('inputs'); dc.onopen=()=>pill('pDc','ok','DC: open'); dc.onclose=()=>pill('pDc','bad','DC: closed');

      pc.ontrack=(e)=>{
        if(!inbound.getTracks().includes(e.track)) inbound.addTrack(e.track);
        if(vid.srcObject!==inbound) vid.srcObject=inbound;
        pill('pAv','ok','A/V: attached'); hideOverlay(); ensurePlay();
        if(e.track.kind==='video'){ lockAspectFromTrack(e.track); retryDelay = 700; }
      };
      pc.oniceconnectionstatechange=()=>{ const s=pc.iceConnectionState; pill('pIce', (s==='connected'||s==='completed')?'ok':(s==='failed'?'bad':'warn'), 'ICE: '+s);
        if (['disconnected','failed','closed'].includes(s)) { handleDisconnect("ICE " + s); }
      };
      pc.onconnectionstatechange=()=>{ const s=pc.connectionState; pill('pPc', s==='connected'?'ok':(s==='failed'?'bad':'warn'), 'Peer: '+s);
        if (['disconnected','failed','closed'].includes(s)) { handleDisconnect("PeerConnection " + s); }
      };

      ws=new WebSocket(wsUrl);
      ws.onopen=()=>{ log('WS open'); pill('pWs','ok','WS: open'); ws.send(JSON.stringify({type:'hello',role:'viewer'})); startHeartbeats(); };
      ws.onerror=()=>{ handleDisconnect("WebSocket error"); };
      ws.onclose=()=>{ handleDisconnect("WebSocket closed"); };
      ws.onmessage=async(ev)=>{ const msg=JSON.parse(ev.data); if(msg.type==='pong') return;
        if(msg.type==='welcome'){ viewerID=msg.viewer_id; const offer=await pc.createOffer(); await pc.setLocalDescription(offer); ws.send(JSON.stringify({type:'offer',viewer:viewerID,sdp:{type:offer.type,sdp:offer.sdp}})); }
        else if(msg.type==='answer'){ await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp)); log('Answer applied'); pill('pSig','ok','Signaling: answer'); hideOverlay(); ensurePlay(); }
        else if(msg.type==='candidate'){ try{ await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); }catch(e){ log('ICE add err '+e); } }
      };

      if (dc) {
        dc.onclose = () => handleDisconnect("DataChannel closed");
        dc.onerror = () => handleDisconnect("DataChannel error");
      }
    }

    function showOverlay(text){ if(text) ovText.textContent=text; overlay.hidden=false; }
    function hideOverlay(){ overlay.hidden=true; }
    function startHeartbeats(){ if(hbTimer) clearInterval(hbTimer); hbTimer=setInterval(()=>{ try{ if(ws&&ws.readyState===1) ws.send(JSON.stringify({type:'ping',viewer:viewerID})); if(dc&&dc.readyState==='open') dc.send(JSON.stringify({type:'ping',viewer:viewerID})); }catch{} }, 2500); }
    function restartSoon(){ if(restarting) return; restarting=true; showOverlay('Reconnecting…'); setTimeout(()=>{ restarting=false; stopSession(); startViewer(); retryDelay=Math.min(retryDelay*1.5, 5000); }, retryDelay); }
    function stopSession(){ try{ if(hbTimer) clearInterval(hbTimer); hbTimer=null; }catch{} try{ if(stallTimer) clearInterval(stallTimer); stallTimer=null; }catch{} try{ dc?.close(); }catch{} try{ ws?.close(); }catch{} try{ pc?.close(); }catch{} }

    function startStallDetector(){
      if(stallTimer) clearInterval(stallTimer);
      let vBytesPrev=0, lastOk=performance.now();
      stallTimer=setInterval(async()=>{
        if(!pc) return;
        try{
          const stats = await pc.getStats(); let vBytes=0;
          stats.forEach(r=>{ if(r.type==='inbound-rtp' && r.kind==='video' && !r.isRemote) vBytes += (r.bytesReceived||0); });
          const now=performance.now();
          if(vBytes>vBytesPrev){ vBytesPrev=vBytes; lastOk=now; pill('pAv','ok','A/V: receiving'); hideOverlay(); ensurePlay(); }
          else if(now-lastOk>4500){ showOverlay('Reconnecting…'); restartSoon(); }
          else if(now-lastOk>2000){ pill('pAv','warn','A/V: stalled'); showOverlay('Buffering…'); }
        }catch{}
      }, 1000);
    }

	// Inputs (send only)
	let inputTimer = null, lastPayload = '';
	const buttonMap = {0:'A',1:'B',2:'X',3:'Y',4:'LB',5:'RB',8:'Back',9:'Start',10:'LS',11:'RS',12:'DPadUp',13:'DPadDown',14:'DPadLeft',15:'DPadRight'};

	// Only cache after a successful send (fixes “no channel yet” dedupe bug)
	function sendInput(o){
	  const s = JSON.stringify(o);
	  const canSendDC = (dc && dc.readyState === 'open');
	  const canSendWS = (ws && ws.readyState === 1);

	  if (!canSendDC && !canSendWS) {
		// No channel yet; don't cache s so we retry next tick when a channel opens
		return;
	  }
	  if (s === lastPayload) return;

	  try {
		if (canSendDC) {
		  log("[SEND] DataChannel: " + s);
		  dc.send(s);
		  lastPayload = s;
		} else if (canSendWS) {
		  log("[SEND] WebSocket: " + s);
		  ws.send(s);
		  lastPayload = s;
		}
	  } catch (e) {
		log("[SEND ERROR] " + e);
	  }
	}

	function startInputs(){
	  if (inputTimer) return;

	  // Minimal stick-center calibration
	  let haveBaseline = false;
	  let base = [0,0,0,0];
	  let sum = [0,0,0,0];
	  let samples = 0;
	  const CALIB_SAMPLES = 20; // ~0.66s at 33ms

	  const DZ = 0.06;
	  const clamp1 = v => Math.max(-1, Math.min(1, v || 0));
	  const q = v => Math.round(v*100)/100;
	  const shapeDeadzone = (v) => {
		const m = Math.abs(v);
		if (m <= DZ) return 0;
		const s = Math.sign(v);
		return s * ((m - DZ) / (1 - DZ));
	  };

	  // For logging once
	  let loggedPadInfo = false;

	  inputTimer = setInterval(()=>{
		const gps = (navigator.getGamepads && Array.from(navigator.getGamepads()).filter(Boolean)) || [];
		const gp = gps.find(g => g && g.connected) || null;

		const buttons = [];
		const triggers = { LT:0, RT:0 };
		let lx=0, ly=0, rx=0, ry=0;

		if (gp) {
		  if (!loggedPadInfo) {
			try {
			  log(`[PAD] mapping=${gp.mapping||'(none)'} axes=${(gp.axes||[]).length} buttons=${(gp.buttons||[]).length}`);
			} catch {}
			loggedPadInfo = true;
		  }

		  // Buttons
		  gp.buttons.forEach((b,i)=>{
			if (b && (b.pressed || (typeof b.value==='number' && b.value>0.5))) {
			  const n = buttonMap[i];
			  if (n) buttons.push(n);
			}
		  });

		  // Raw axes (standard default indices)
		  const ax = [
			clamp1(gp.axes[0]),
			clamp1(gp.axes[1]),
			clamp1(gp.axes[2]),
			clamp1(gp.axes[3]),
		  ];

		  // Detect the “corner at idle” pattern and treat it as baseline immediately
		  const looksExtremeCorner =
			Math.abs(ax[0]) > 0.95 && Math.abs(ax[1]) > 0.95 &&
			Math.abs(ax[2]) > 0.95 && Math.abs(ax[3]) > 0.95;

		  if (!haveBaseline) {
			if (looksExtremeCorner) {
			  base = ax.slice();
			  haveBaseline = true;
			  log(`[PAD] Baseline set from extreme idle: [${base.map(v=>v.toFixed(2)).join(', ')}]`);
			} else {
			  // Average a few frames to estimate center
			  sum[0]+=ax[0]; sum[1]+=ax[1]; sum[2]+=ax[2]; sum[3]+=ax[3];
			  samples++;
			  if (samples >= CALIB_SAMPLES) {
				base = sum.map(v=>v/samples);
				haveBaseline = true;
				log(`[PAD] Baseline calibrated: [${base.map(v=>v.toFixed(2)).join(', ')}]`);
			  }
			}
		  }

		  // Subtract baseline (once available)
		  const adj = haveBaseline ? [
			clamp1(ax[0] - base[0]),
			clamp1(ax[1] - base[1]),
			clamp1(ax[2] - base[2]),
			clamp1(ax[3] - base[3]),
		  ] : ax;

		  // Deadzone shaping
		  lx = shapeDeadzone(adj[0]);
		  ly = shapeDeadzone(adj[1]);
		  rx = shapeDeadzone(adj[2]);
		  ry = shapeDeadzone(adj[3]);

		  // Triggers (0..1)
		  if (gp.buttons[6]) triggers.LT = Math.max(0, Math.min(1, gp.buttons[6].value||0));
		  if (gp.buttons[7]) triggers.RT = Math.max(0, Math.min(1, gp.buttons[7].value||0));
		}

		// Apply button remap + dedupe
		const remapped = [];
		const seen = new Set();
		for (const phys of buttons) {
		  const virtualName = (remap[phys] ?? phys);
		  if (virtualName && !seen.has(virtualName)) {
			seen.add(virtualName);
			remapped.push(virtualName);
		  }
		}

		const axes = [ q(lx), q(ly), q(rx), q(ry) ];
		// Old-style payload (host accepts with or without type)
		sendInput({ buttons: remapped, axes, triggers });
	  }, 33);

	  log('Input sender started (with minimal center calibration)');
	}

	// Start the input loop shortly after load and on first pad connect
	window.addEventListener('load', () => { setTimeout(startInputs, 300); });
	window.addEventListener('gamepadconnected', () => { setTimeout(startInputs, 0); });

    // Start
    setChatSrc();
    startViewer();
    buildBanner();
    window.addEventListener('load', ()=>{ setTimeout(startInputs,300); document.body.classList.remove('chat-open'); chatWrap.hidden=true; });

    // Instant download logs
    document.getElementById('btnDownloadLogs').onclick=()=>{
      try{
        const blob = new Blob([logEl.textContent||''], {type:'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'viewer-log.txt';
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      }catch(e){ log('Download failed'); }
    };

    window.addEventListener('beforeunload', ()=>{ try{ clearInterval(inputTimer); }catch{} });
  </script>
</body>
</html>
