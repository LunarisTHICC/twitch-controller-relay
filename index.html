<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>doppel.stream</title>
  <meta name="application-name" content="doppel.stream">
  <meta property="og:title" content="doppel.stream">
  <meta property="og:type" content="website">
  <meta property="og:image" content="/social-card.png">
  <meta property="og:url" content="https://doppel.stream">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Oswald for intro, Montserrat/Orbitron for main UI -->
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Montserrat:wght@500;700&family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg?v=1"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png?v=1"> <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png?v=1"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1"> <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#9146ff"> <meta name="theme-color" content="#0e1524">
  <style>
    :root {
      --bg: #0e0e10; --panel: #18181b; --edge: #23232a; --fg: #efeff1; --muted: #b9b9c2;
      --accent: #9146ff; --accent-2: #772ce8; --ok: #22c55e; --warn: #f59e0b; --bad: #ef4444;
      --chat-w: 360px; --banner-h: 44px;
      --header-h: 48px;
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
      overscroll-behavior-y: none;
    }
    body { min-height: 100vh; }

    button, input, select, label { font-family: "Orbitron", system-ui, sans-serif; letter-spacing: 0.4px; }

    /* Banner */
    #brandBanner {
      position: relative;
      top: 0;
      z-index: 50;
      height: var(--banner-h);
      background: linear-gradient(90deg, rgba(12,10,22,.9), rgba(20,14,38,.9));
      border-bottom: 1px solid #241d3a;
      overflow: hidden;
      display: flex;
      align-items: center;
      width: 100%;
    }
	#brandTrack { display: flex; gap: 40px; align-items: center; white-space: nowrap; will-change: transform; animation: scrollX 39s linear infinite }
	#brandTrack .item{ font-family:"Orbitron",system-ui,sans-serif; font-size:14px; letter-spacing:1.4px; line-height:1; color:#e9e2ff; text-shadow:0 0 12px rgba(145,70,255,.55), 0 0 2px rgba(145,70,255,.35) }
    .dot{display:inline-block;width:7px;height:7px;border-radius:50%;background:var(--accent);box-shadow:0 0 10px var(--accent)}
    @keyframes scrollX{0%{transform:translateX(0)}100%{transform:translateX(-50%)}}

	/* Viewer count indicator (left of Remap) */
	#viewerCount {
	  display: inline-flex;
	  align-items: center;
	  gap: 6px;
	  padding: 6px 10px;
	  border-radius: 999px;
	  font-size: 12px;
	  line-height: 14px;
	  font-family: "Orbitron", system-ui, sans-serif;
	  letter-spacing: 0.6px;
	  color: #e9e2ff;
	  background: #1b1232;
	  border: 1px solid #3a2a62;
	  box-shadow: 0 0 12px rgba(145,70,255,0.25), inset 0 0 0 1px rgba(255,255,255,0.04);
	  transition: filter .2s, box-shadow .2s, background-color .2s, border-color .2s, color .2s, transform .1s;
	}
	#viewerCount:hover { filter: brightness(1.05); }
	#viewerCount svg {
	  width: 16px;
	  height: 16px;
	  display: block;
	  filter: drop-shadow(0 0 6px rgba(145,70,255,0.5));
	}
	#viewerCount.hot {
	  color: #fff1f1;
	  background: #2a1212;
	  border-color: #702323;
	  box-shadow:
		0 0 14px rgba(239, 68, 68, 0.35),
		0 0 4px rgba(239, 68, 68, 0.35),
		inset 0 0 0 1px rgba(255, 255, 255, 0.04);
	}
	#viewerCount.hot svg {
	  filter: drop-shadow(0 0 8px rgba(239,68,68,0.65));
	}

    /* Debug header */
    header{display:flex;align-items:center;gap:8px;padding:8px 14px;background:#1f1f23;border-bottom:1px solid var(--edge);position:sticky;top:var(--banner-h);z-index:10;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;line-height:14px;background:#2a2a32;border:1px solid #3a3a4a;color:#cfd3df}
    .pill.ok{background:#15321f;border-color:#1e6a33;color:#a5e7b9}
    .pill.warn{background:#3a2a18;border-color:#b57a28;color:#ffd89a}
    .pill.bad{background:#3a1a1a;border-color:#b52828;color:#ff9a9a}
    #wsUrl{margin-left:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#9fb2d1}

    /* Layout */
    html, body {
      height: 100%;
      min-height: 100%;
    }
    body, #root {
      min-height: 100vh;
      width: 100%;
      margin: 0;
      padding: 0;
    }
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      padding: 12px;
      box-sizing: border-box;
      min-height: calc(100vh - var(--banner-h) - var(--header-h) - 60px);
    }
    body.chat-open #sidePanel{display:grid;}
    body.chat-open main{ grid-template-columns:1fr var(--chat-w); }

    /* Responsive Video */
    #videoWrap {
      position: relative;
      background: #0f1320;
      border: 1px solid #1d2436;
      border-radius: 8px;
      overflow: hidden;
      aspect-ratio: 16/9;
      min-height: 180px;
      max-height: calc(100vh - var(--banner-h) - var(--header-h) - 60px);
      height: 65vw;
      max-width: 100%;
      width: 100%;
      contain: layout paint;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 0 auto;
      box-sizing: border-box;
    }
    @media (max-width: 900px) {
      #videoWrap { height: 48vw; min-height: 140px; }
    }
    @media (max-width: 700px) {
      #videoWrap { height: 38vw; min-height: 90px; }
    }
    @media (max-width: 600px) {
      #videoWrap { height: 30vw; min-height: 60px; }
      main { padding: 5px; }
    }
    #vid { width: 100%; height: 100%; display: block; background: #000; object-fit: contain; aspect-ratio: inherit }
    #overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(10,14,21,.65),rgba(10,14,21,.75));pointer-events:none;transition:opacity .15s}
    #overlay[hidden]{display:none}
    #ovText{font-size:16px;color:#c6d3ea;text-shadow:0 1px 2px rgba(0,0,0,.6)}

    /* Controls */
	/* Remap dropdown */
	#controls { position: relative; }
	#btnRemap { /* same accent style already inherited, just keep id */ }
	#remapPanel {
	  position: absolute;
	  top: calc(100% + 8px);
	  left: 0;
	  min-width: 340px;
	  max-width: 92vw;
	  background: #0d1322;
	  color: #efeff1;
	  border: 1px solid #1d2436;
	  border-radius: 10px;
	  box-shadow: 0 8px 30px rgba(0,0,0,0.45);
	  padding: 12px;
	  z-index: 9000;
	}
	#remapPanel[hidden] { display: none; }
	#remapHeader {
	  display: flex; align-items: center; justify-content: space-between; gap: 10px;
	  padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #1d2436;
	}
	#remapHeader h3 {
	  margin: 0; font-size: 14px; font-weight: 700; letter-spacing: .6px; color: #cfd3df;
	  font-family: "Orbitron","Montserrat",system-ui,sans-serif;
	}
	#remapGrid {
	  display: grid; grid-template-columns: 120px 1fr; gap: 8px 10px; align-items: center;
	}
	#remapGrid label {
	  font-size: 12px; color: #b9b9c2; text-align: right; padding-right: 4px; user-select: none;
	}
	#remapGrid select {
	  border-radius: 8px; border: 1px solid #2a2a32; color: #f3edff; background: #1e123a;
	  padding: 6px 8px; font-size: 12px; width: 100%;
	}
	#remapFooter {
	  display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px;
	}
	#remapFooter button {
	  border-radius: 8px; border: 1px solid #2a2a32; background: #1e123a; color: #efeff1; padding: 6px 12px;
	}
	#remapFooter button.accent {
	  background: linear-gradient(180deg, var(--accent), var(--accent-2));
	  border-color: #5f37d6; color: #fff; box-shadow: 0 6px 18px rgba(145,70,255,.25), inset 0 0 0 1px rgba(255,255,255,.05)
	}

	/* Make sure Remap remains visible in "clean" mode */
	/* Clean mode: ensure the counter is visible */
	body.clean #controls > #viewerCount { display: inline-flex; }
	body.clean #controls > * { display: none; }
	body.clean #controls > #btnRemap { display: flex; }
	body.clean #controls > #btnChat,
	body.clean #controls > #volumeWrap,
	body.clean #controls > #btnFullscreen,
	body.clean #controls > #iconRow { display: flex; }
	/* Allow panel to show in clean mode when not hidden */
	body.clean #controls > #remapPanel:not([hidden]) { display: block; }
    #controls{display:flex;flex-wrap:wrap;gap:10px;padding:10px 0;align-items:center}
    button,input,select{border-radius:8px;border:1px solid #2a2a32;color:#f3edff;background:#1e123a}
    button.accent{background:linear-gradient(180deg,var(--accent),var(--accent-2));border-color:#5f37d6;color:#fff;box-shadow:0 6px 18px rgba(145,70,255,.25),inset 0 0 0 1px rgba(255,255,255,.05)}
    button.accent:hover{filter:brightness(1.05)} button.accent:active{transform:translateY(1px)}
    input[type=range]{appearance:none;height:6px;background:#1d1931;border:1px solid #2b2350;width:160px;border-radius:999px}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 0 8px rgba(145,70,255,.55);border:1px solid #fff1}

    /* Side panel */
    #sidePanel{display:none;grid-template-rows:min-content 1fr;gap:10px}
    #chatWrap {
      border: 1px solid #1d2436;
      border-radius: 8px;
      overflow: hidden;
      background: #0d1322;
      min-height: 320px;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-width: 200px;
      width: 100%;
    }
    #chatIframe {
      width: 100%;
      height: 100%;
      min-height: 320px;
      flex: 1 1 0;
      display: block;
      border: 0;
      background: #0d1322 !important;
      color-scheme: dark;
      color: #fff;
    }
    /* Force dark mode for Twitch chat iframe container */
    .twitch-dark-bg {
      background: #0d1322 !important;
      color-scheme: dark !important;
    }

    /* Logs (debugger) */
    #logPanel{display:grid;grid-template-rows:min-content 1fr;border:1px solid #1d2436;border-radius:8px;overflow:hidden}
    #logHeader{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:#121824;border-bottom:1px solid #1d2436}
    #log{margin:0;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.4;background:#0d1322;white-space:pre;overflow:auto}

    /* Footer */
    footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      color:#7a8fb2;
      border-top:1px solid #20283a;
      background:#0e1524
    }
    #footerNoticeWrap {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #footerNoticeWrap .footer-eye-btn {
      background: none;
      border: none;
      padding: 0;
      margin-right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: filter 0.2s;
    }
    #footerNoticeWrap .footer-eye-btn:hover {
      filter: drop-shadow(0 0 8px #9146ff);
      opacity: 0.9;
    }
    #footerNoticeText {
      font-size: 0.98em;
      color: #aeb6d3;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      letter-spacing: 0.04em;
    }
    #footerRight{margin-left:auto;display:flex;align-items:center;gap:8px}
    #btnDebugger{padding:6px 10px;font-size:12px;opacity:.9}

    /* Connection Lost Overlay */
    #lostConnectionOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(10,10,16,0.97);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #lostConnectionMsg {
      font-size: 1.5em;
      color: #fff;
      margin-bottom: 1em;
      text-align: center;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      text-shadow: 0 2px 18px #000;
    }
    #lostConnectionOverlay .footer-eye-btn {
      margin-bottom: 1em;
      filter: drop-shadow(0 0 4px #9146ff);
    }
    #reconnectBtn {
      background: linear-gradient(180deg,#9146ff,#772ce8);
      border: none;
      color: #fff;
      border-radius: 8px;
      padding: 0.5em 1.7em;
      font-size: 1.12em;
      font-family: 'Orbitron',sans-serif;
      cursor: pointer;
      letter-spacing: 0.06em;
      margin: 0 0.5em;
      box-shadow: 0 2px 14px #9146ff55;
      transition: background 0.15s;
    }
    #reconnectBtn:hover {
      background: linear-gradient(180deg,#a86afe,#a95cff);
      filter: brightness(1.08);
    }
    #reconnectCountdown {
      font-size: 1.12em;
      margin-top: 0.7em;
      color: #aeb6d3;
      font-family: 'Orbitron', 'Montserrat', Arial, sans-serif;
      letter-spacing: 0.04em;
    }
    /* Clean vs Debugger */
    body.clean header{display:none!important}
    body.clean #logPanel{display:none!important}
    body.clean #controls>*{display:none}
    body.clean #btnChat, body.clean #volumeWrap, body.clean #btnFullscreen, body.clean #iconRow{display:flex}
    body:not(.clean) #btnFullscreen{display:none}
    .fs-active #videoWrap{box-shadow:0 0 0 2px var(--accent) inset}

    /* --- Animated Intro Styles --- */
    #intro-overlay {
      position: fixed;
      inset: 0;
      background: black;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1s;
      opacity: 1;
      pointer-events: auto;
    }
    #eyes-container {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      gap: 60px;
      position: relative;
      width: 340px;
      max-width: 90vw;
      margin: 0 auto;
    }
    .eye-wrap {
      transition: opacity 0.9s, transform 0.7s cubic-bezier(.8,2,.6,1);
      will-change: transform, opacity;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
    }
    .eye-wrap.visible {
      opacity: 1;
    }
    .eye-svg {
      width: 120px;
      height: 80px;
      display: block;
    }
    #intro-text {
      color: #e5e5e5;
      font-size: clamp(40px, 7vw, 96px);
	  white-space: nowrap;
      font-family: 'Oswald', 'Arial Narrow', Arial, Helvetica, sans-serif;
      font-weight: 700;
      letter-spacing: 0.12em;
      opacity: 0;
      margin-top: 6px;
      background: none;
      transition: opacity 2s;
      text-align: center;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 4px rgba(0,0,0,0.18);
      text-transform: uppercase;
    }
    #intro-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    /* --- Mobile chat-under-video layout (additions) --- */
    @media (max-width: 900px) {
      #sidePanel { width: 100%; }
      #chatWrap { min-height: 260px; }
    }
    @media (max-width: 700px) {
      body.chat-open main {
        grid-template-columns: 1fr !important; /* override desktop two-column rule */
      }
      /* Ensure stacking order on small screens */
      main > section { order: 1; }
      main > #sidePanel { order: 2; }

      /* Slightly taller video on small screens */
      #videoWrap { height: 48vw; min-height: 160px; }
    }
  </style>
</head>
<body class="clean">

  <!-- Animated HTML Intro Overlay -->
  <div id="intro-overlay">
    <div id="eyes-container"></div>
    <div id="intro-text">doppel.stream</div>
  </div>
  <!-- End Intro -->

  <div id="brandBanner" role="banner" aria-label="Credits banner"><div id="brandTrack"></div></div>

  <header>
    <span id="pRelay" class="pill">Relay</span><span id="pWs" class="pill">WS</span><span id="pSig" class="pill">Signaling</span><span id="pIce" class="pill">ICE</span><span id="pDtls" class="pill">DTLS</span>
    <span id="wsUrl" class="pill">ws://</span>
  </header>

  <main>
    <section>
      <div id="videoWrap">
        <video id="vid" playsinline muted autoplay></video>
        <div id="overlay"><div id="ovText">Connecting…</div></div>
      </div>
      <div id="controls">
	  <div id="viewerCount" title="Connected viewers">
	  <svg viewBox="0 0 24 24" aria-hidden="true">
		<!-- Person icon -->
		<path fill="#e5e5e5" d="M12 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm-8 8v-1a6 6 0 0 1 12 0v1H4Z"/>
	  </svg>
	  <span id="viewerCountNum">0</span>
	</div>
        <button id="btnRemap" class="accent" title="Remap controller buttons">Remap</button>
        <div id="remapPanel" hidden>
          <div id="remapHeader">
            <h3>Viewer Control Remap</h3>
            <div style="font-size:11px;color:#9aa7c8;opacity:.9">Maps your physical button → virtual button sent to host</div>
          </div>
          <div id="remapGrid"></div>
          <div id="remapFooter">
            <button id="btnRemapReset">Reset</button>
            <button id="btnRemapClose" class="accent">Close</button>
          </div>
        </div>
        <button id="btnChat" class="accent" title="Toggle Twitch chat">Twitch Chat</button>

        <div id="volumeWrap" style="display:flex;align-items:center;gap:8px">
          <label for="vol" style="opacity:.8">Volume</label>
          <input id="vol" type="range" min="0" max="100" value="0" />
          <div id="iconRow">
            <button id="btnMute" class="muted" aria-label="Toggle mute" title="Toggle audio">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 10v4h4l5 4V6L7 10H3z"></path>
                <path d="M14.5 12a4.5 4.5 0 0 0-1.2-3.1l1.4-1.4A6.5 6.5 0 0 1 16.5 12a6.5 6.5 0 0 1-1.8 4.5l-1.4-1.4A8 8 0 0 0 18 12z"></path>
                <path d="M18 12a8 8 0 0 0-2.1-5.4l1.4-1.4A10 10 0 0 1 20 12a10 10 0 0 1-2.7 6.8l-1.4-1.4A8 8 0 0 0 18 12z"></path>
              </svg>
            </button>
            <div id="padIconWrap" class="off" title="Controller status">
              <svg id="padIcon" class="off" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 8h10a4 4 0 0 1 3.8 2.7l1.1 3.2A3 3 0 0 1 19 18h-1.7l-1.8-2H8.5l-1.8 2H5A3 3 0 0 1 2.1 13.9l1.1-3.2A4 4 0 0 1 7 8zm3 2H8v2H6v2h2v2h2v-2h2v-2h-2v-2zm8 1.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
              </svg>
            </div>
          </div>
        </div>

        <button id="btnFullscreen" class="accent" title="Fullscreen">Fullscreen</button>
        <button id="btnDownloadLogs">Download logs</button>
      </div>
    </section>

    <aside id="sidePanel">
      <div id="chatWrap" hidden><iframe id="chatIframe" title="Twitch chat"></iframe></div>
      <div id="logPanel"><div id="logHeader"><strong>Viewer logs</strong><span style="opacity:.7">Use “Download logs”.</span></div><pre id="log"></pre></div>
    </aside>
  </main>

  <footer>
    <div id="footerNoticeWrap">
      <button class="footer-eye-btn" tabindex="-1" aria-label="Animated Eye" style="background:none;border:none;outline:none;padding:0;">
        <svg class="eye-svg" viewBox="0 0 120 80" width="34" height="24">
          <ellipse class="eyeball" cx="60" cy="40" rx="28" ry="18" stroke="#e5e5e5" stroke-width="3" fill="#181818"/>
          <ellipse class="iris" cx="60" cy="40" rx="10" ry="10" fill="#e5e5e5"/>
          <ellipse class="pupil" cx="60" cy="40" rx="5" ry="5" fill="#1a1a1a"/>
        </svg>
      </button>
      <span id="footerNoticeText">Not affiliated by Twitch and all code complies with ToS.</span>
    </div>
    <div id="footerRight"><button id="btnDebugger" title="Toggle debug UI">Debugger</button></div>
  </footer>

  <!-- Scripts: Animated Intro (runs first), then Viewer scripts -->
  <script>
	// --- Animated Intro JS ---
	// Use #e5e5e5 for all "white" lines (10% darker than #fff)
	function getEyeSVG(rx = 50, ry = 30, pupilDx = 0, pupilDy = 0, eyelidOpacity = 0) {
	  return `
	<svg class="eye-svg" viewBox="0 0 120 80" fill="none">
	  <ellipse class="eyeball" cx="60" cy="40" rx="${rx}" ry="${ry}" stroke="#e5e5e5" stroke-width="4" fill="#181818"/>
	  <ellipse class="iris" cx="${60 + pupilDx}" cy="${40 + pupilDy}" rx="18" ry="18" fill="#e5e5e5"/>
	  <ellipse class="pupil" cx="${60 + pupilDx}" cy="${40 + pupilDy}" rx="8" ry="8" fill="#1a1a1a"/>
	  <ellipse class="eyelid" cx="60" cy="40" rx="${rx}" ry="${ry}" fill="black" style="opacity:${eyelidOpacity};"/>
	</svg>
		  `;
	}

	const overlayIntro = document.getElementById('intro-overlay');
	const eyesContainer = document.getElementById('eyes-container');
	const introText = document.getElementById('intro-text');
	let animationSkipped = false;
	let skipTimeout;

	function animateEyeShape(eye, opts, duration = 400) {
	  const eyeball = eye.querySelector('.eyeball');
	  const iris = eye.querySelector('.iris');
	  const pupil = eye.querySelector('.pupil');
	  let start = null;
	  const rx0 = +eyeball.getAttribute('rx');
	  const ry0 = +eyeball.getAttribute('ry');
	  const irisCx0 = +iris.getAttribute('cx');
	  const irisCy0 = +iris.getAttribute('cy');
	  const pupilCx0 = +pupil.getAttribute('cx');
	  const pupilCy0 = +pupil.getAttribute('cy');
	  const rx1 = opts.rx;
	  const ry1 = opts.ry;
	  const irisCx1 = 60 + opts.pupilDx;
	  const irisCy1 = 40 + opts.pupilDy;
	  const pupilCx1 = 60 + opts.pupilDx;
	  const pupilCy1 = 40 + opts.pupilDy;

	  function stepEye(ts) {
		if (!start) start = ts;
		let t = Math.min(1, (ts - start)/duration);
		t = t<0.5 ? 4*t*t*t : 1-(-2*t+2)**3/2;
		eyeball.setAttribute('rx', rx0 + (rx1 - rx0)*t);
		eyeball.setAttribute('ry', ry0 + (ry1 - ry0)*t);
		iris.setAttribute('cx', irisCx0 + (irisCx1 - irisCx0)*t);
		iris.setAttribute('cy', irisCy0 + (irisCy1 - irisCy0)*t);
		pupil.setAttribute('cx', pupilCx0 + (pupilCx1 - pupilCx0)*t);
		pupil.setAttribute('cy', pupilCy0 + (pupilCy1 - pupilCy0)*t);
		const eyelid = eye.querySelector('.eyelid');
		eyelid.setAttribute('rx', rx0 + (rx1 - rx0)*t);
		eyelid.setAttribute('ry', ry0 + (ry1 - ry0)*t);
		if (t < 1) requestAnimationFrame(stepEye);
	  }
	  requestAnimationFrame(stepEye);
	}

	function setBlink(eye, closed, duration = 200) {
	  const eyelid = eye.querySelector('.eyelid');
	  eyelid.style.transition = `opacity ${duration}ms`;
	  eyelid.style.opacity = closed ? 1 : 0;
	}
	function widenEye(eye, widened = true) {
	  const eyeball = eye.querySelector('.eyeball');
	  const eyelid = eye.querySelector('.eyelid');
	  const targetRy = widened ? 38 : 30;
	  eyeball.setAttribute('ry', targetRy);
	  eyelid.setAttribute('ry', targetRy);
	}

	function fadeInEyeWrap(eyeWrap, duration = 900, cb) {
	  eyeWrap.style.transition = `opacity ${duration}ms`;
	  setTimeout(() => {
		eyeWrap.style.opacity = 1;
		if (typeof cb === "function") setTimeout(cb, duration);
	  }, 20);
	}

	function fadeOut(element, duration = 800) {
	  element.style.opacity = 0;
	  element.style.transition = `opacity ${duration}ms`;
	}

	function fadeIn(element, duration = 2000) {
	  element.style.opacity = 1;
	  element.style.transition = `opacity ${duration}ms`;
	}

	function animateIntro() {
	  eyesContainer.innerHTML = '';
	  introText.style.opacity = 0;
	  introText.style.backgroundPosition = 'left';

	  const eyeForward = {rx:50, ry:30, pupilDx:0, pupilDy:0};
	  const eyeTurnLeft = {rx:40, ry:33, pupilDx:-23, pupilDy:2};
	  const eyeTurnRight = {rx:40, ry:33, pupilDx:23, pupilDy:2};
	  const leftStartOffset = 0;
	  const leftEndOffset = 0;

	  // Create left eye wrap, opacity 0 for fade-in, start closer to center for smooth slide
	  const leftEyeWrap = document.createElement('div');
	  leftEyeWrap.className = 'eye-wrap';
	  leftEyeWrap.style.opacity = 0;
	  leftEyeWrap.style.transform = `translateX(${leftStartOffset}px)`;
	  leftEyeWrap.innerHTML = getEyeSVG(eyeForward.rx, eyeForward.ry, eyeForward.pupilDx, eyeForward.pupilDy, 0);
	  eyesContainer.appendChild(leftEyeWrap);

	  fadeInEyeWrap(leftEyeWrap, 900, () => {
		if (animationSkipped) return skipToEnd();
		setBlink(leftEyeWrap.firstElementChild, true, 120);
		setTimeout(() => setBlink(leftEyeWrap.firstElementChild, false, 160), 180);

		// After a second, fade in right eye and slide left eye smoothly
		setTimeout(() => {
		  if (animationSkipped) return skipToEnd();
		  const rightEyeWrap = document.createElement('div');
		  rightEyeWrap.className = 'eye-wrap';
		  rightEyeWrap.style.opacity = 0;
		  rightEyeWrap.innerHTML = getEyeSVG(eyeForward.rx, eyeForward.ry, eyeForward.pupilDx, eyeForward.pupilDy, 0);

		  // FLIP: measure before layout change
		  const firstRect = leftEyeWrap.getBoundingClientRect();

		  // Append right eye (causes layout shift)
		  eyesContainer.appendChild(rightEyeWrap);

		  // Measure after layout change
		  const lastRect = leftEyeWrap.getBoundingClientRect();
		  const deltaX = firstRect.left - lastRect.left;

		  // Invert: keep left eye visually in place, then animate to final
		  const computed = getComputedStyle(leftEyeWrap);
		  const baseMatrix = computed.transform === 'none' ? 'matrix(1,0,0,1,0,0)' : computed.transform;
		  const matrix = new DOMMatrixReadOnly(baseMatrix);
		  const currentX = matrix.m41 || 0;

		  leftEyeWrap.style.transform = `translateX(${currentX + deltaX}px)`;
		  leftEyeWrap.style.willChange = 'transform, opacity';

		  // Force reflow so the inverted transform takes effect
		  void leftEyeWrap.offsetWidth;

		  // Play: glide to intended position, fade in right eye
		  requestAnimationFrame(() => {
			leftEyeWrap.style.transition = 'transform 0.7s cubic-bezier(.8,2,.6,1), opacity 0.7s';
			leftEyeWrap.style.transform = `translateX(${leftEndOffset}px)`;
			fadeInEyeWrap(rightEyeWrap, 900);
		  });

		  setTimeout(() => {
			if (animationSkipped) return skipToEnd();
			animateEyeShape(leftEyeWrap.firstElementChild, eyeTurnRight, 400);
			animateEyeShape(rightEyeWrap.firstElementChild, eyeTurnLeft, 400);
			widenEye(leftEyeWrap.firstElementChild, true);
		  }, 700);

		  setTimeout(() => {
			if (animationSkipped) return skipToEnd();
			setBlink(leftEyeWrap.firstElementChild, true, 80);
			setBlink(rightEyeWrap.firstElementChild, true, 80);
			setTimeout(() => {
			  setBlink(leftEyeWrap.firstElementChild, false, 100);
			  setBlink(rightEyeWrap.firstElementChild, false, 100);

			  setTimeout(() => {
				setBlink(leftEyeWrap.firstElementChild, true, 80);
				setBlink(rightEyeWrap.firstElementChild, true, 80);

				setTimeout(() => {
				  setBlink(leftEyeWrap.firstElementChild, false, 100);
				  setBlink(rightEyeWrap.firstElementChild, false, 100);

				  setTimeout(() => {
					animateEyeShape(leftEyeWrap.firstElementChild, eyeForward, 350);
					animateEyeShape(rightEyeWrap.firstElementChild, eyeForward, 350);
					widenEye(leftEyeWrap.firstElementChild, false);

					setTimeout(() => {
					  if (animationSkipped) return skipToEnd();
					  fadeIn(introText, 2000);
					  introText.style.backgroundPosition = 'right';
					  setTimeout(() => {
						fadeOut(leftEyeWrap, 600);
						fadeOut(rightEyeWrap, 600);
						fadeOut(introText, 600);
						setTimeout(() => fadeOut(overlayIntro, 800), 600);
					  }, 1300);
					}, 380);
				  }, 350);
				}, 180);
			  }, 160);
			}, 110);
		  }, 900);
		}, 1100);
	  });

	  skipTimeout = setTimeout(() => fadeOut(overlayIntro, 900), 10100);
	}
    function skipToEnd() {
      if (animationSkipped) return;
      animationSkipped = true;
      clearTimeout(skipTimeout);
      fadeOut(overlayIntro, 700);
    }

    function setupSkip() {
      let lastClick = 0, clickCount = 0, lastKey = 0, keyCount = 0;
      overlayIntro.addEventListener('click', () => {
        const now = Date.now();
        if (now - lastClick < 400) clickCount++;
        else clickCount = 1;
        lastClick = now;
        if (clickCount >= 2) skipToEnd();
      });
      window.addEventListener('keydown', (e) => {
        const now = Date.now();
        if (now - lastKey < 400) keyCount++;
        else keyCount = 1;
        lastKey = now;
        if (keyCount >= 2) skipToEnd();
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      animateIntro();
      setupSkip();
      overlayIntro.addEventListener('transitionend', () => {
        if (overlayIntro.style.opacity === '0') overlayIntro.style.display = 'none';
      });
    });
  </script>
  <script>
    // --- Viewer.html JS: all original code below, with connection lost overlay logic added ---

    const logEl=document.getElementById('log'); function log(m){const t=new Date().toLocaleTimeString(); logEl.textContent+=`[${t}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight;}
    function pill(id,cls,text){const el=document.getElementById(id); if(!el) return; el.className='pill '+(cls||''); if(text) el.textContent=text;}

    // ----- Banner with meta fallbacks -----
    // NOTE: Banner stats are now static per user request!
    const PROJECT_START = new Date('2025-09-29T00:00:00Z');
    const brandTrack = document.getElementById('brandTrack');
    function item(text){ const s=document.createElement('span'); s.className='item'; const d1=document.createElement('i'); d1.className='dot'; const d2=document.createElement('i'); d2.className='dot'; s.appendChild(d1); s.appendChild(document.createTextNode(' ')); s.appendChild(document.createTextNode(text)); s.appendChild(document.createTextNode(' ')); s.appendChild(d2); return s; }
    async function buildBanner(){
      brandTrack.innerHTML='';
      // Static stats per user request
      const now=new Date(); 
      // Local time string formatted as HH:MM (24hr)
      const hh=String(now.getHours()).padStart(2,'0'), mm=String(now.getMinutes()).padStart(2,'0');
      const days=Math.max(1, Math.floor((now-PROJECT_START)/86400000));
      const texts = [
        `Local time: ${hh}:${mm}`,
        `Viewer mode: ${document.body.classList.contains('clean') ? 'Clean' : 'Debugger'}`,
        `Made by JunkfoodJon with CoPilot and GitHub`,
        `How long this project took: ${days} day${days!==1?'s':''}`,
        `Lines of code used: 2635+`,
        `Languages used: Python, HTML, CSS, JavaScript`,
        `Models used: Gpt-5 & GPT-4.`
      ];
      const frag=document.createDocumentFragment();
      for(let k=0;k<2;k++){ texts.forEach(t=>frag.appendChild(item(t))); }
      brandTrack.appendChild(frag);
    }
		// --- Viewer count indicator logic ---
	const viewerCountEl = document.getElementById('viewerCount');
	const viewerCountNumEl = document.getElementById('viewerCountNum');
	let currentUsers = 0;
	const HOT_THRESHOLD = 10;

	function applyViewerCountGlow(n) {
	  if (!viewerCountEl) return;
	  viewerCountEl.classList.toggle('hot', n >= HOT_THRESHOLD);
	}

	function updateCurrentUsers(n) {
	  const num = Math.max(0, Number(n) || 0);
	  currentUsers = num;
	  if (viewerCountNumEl) viewerCountNumEl.textContent = String(num);
	  applyViewerCountGlow(num);
	}

	// Initialize to 0
		updateCurrentUsers(0);
	// Hook WebSocket to listen for viewer count messages on /ws/viewer
	(function () {
	  const NativeWS = window.WebSocket;
	  window.WebSocket = function(url, protocols) {
		const sock = new NativeWS(url, protocols);
		try {
		  if (String(url).includes('/ws/viewer')) {
			sock.addEventListener('open', () => {
			  // Ask server for current count (implement server handler)
			  try { sock.send(JSON.stringify({ type: 'get_viewer_count' })); } catch {}
			});
			sock.addEventListener('message', (e) => {
			  try {
				const msg = JSON.parse(e.data);
				// Accept multiple payload shapes
				if (msg && (
				  msg.type === 'viewer_count' ||
				  msg.type === 'stats' ||
				  msg.type === 'presence' ||
				  typeof msg.viewerCount === 'number' ||
				  typeof msg.currentUsers === 'number' ||
				  typeof msg.viewers === 'number' ||
				  typeof msg.count === 'number'
				)) {
				  const n = msg.count ?? msg.viewerCount ?? msg.viewers ?? msg.currentUsers;
				  if (typeof n === 'number') updateCurrentUsers(n);
				}
			  } catch {}
			});
		  }
		} catch {}
		return sock;
	  };
	  // Preserve prototype chain
	  window.WebSocket.prototype = NativeWS.prototype;
	})();
	
	// Optional REST fallback if your relay exposes /viewer-count
	(function () {
	  const COUNT_URL = `${location.protocol === 'https:' ? 'https' : 'http'}://${(new URL(location.href)).host}/viewer-count`;

	  async function pollViewerCount() {
		try {
		  const r = await fetch(COUNT_URL, { cache: 'no-store', headers: { 'ngrok-skip-browser-warning': '1' } });
		  if (!r.ok) return;
		  let num = NaN;
		  const ct = r.headers.get('content-type') || '';
		  if (ct.includes('application/json')) {
			const j = await r.json();
			const n = j.count ?? j.viewerCount ?? j.viewers ?? j.currentUsers;
			num = Number(n);
		  } else {
			num = Number(await r.text());
		  }
		  if (!Number.isNaN(num)) updateCurrentUsers(num);
		} catch {}
	  }

	  // Poll every 15s
	  pollViewerCount();
	  setInterval(pollViewerCount, 15000);
	})();

	// ----- Chat (force junkfoodjon, dark) -----
	const chatWrap = document.getElementById('chatWrap');
	const chatIframe = document.getElementById('chatIframe');

	function setChatSrc() {
	  if (!chatIframe) return;

	  // Allow override via ?parent= if you’re behind a proxy/CDN
	  const qs = new URLSearchParams(location.search);
	  const parent = (qs.get('parent') || location.hostname);

	  const ch = 'junkfoodjon';

	  // Build embed URL with correct dark flag for chat
	  const params = new URLSearchParams();
	  // Required by Twitch for security
	  params.set('parent', parent);
	  // Chat dark mode flag (correct one)
	  params.set('darkpopout', '1');
	  // Optional: theme is ignored by chat, but harmless to include
	  params.set('theme', 'dark');

	  const url = `https://www.twitch.tv/embed/${encodeURIComponent(ch)}/chat?${params.toString()}`;

	  // Only skip setting src if already loaded with correct params
	  try {
		const cur = new URL(chatIframe.src);
		const hasDark = cur.searchParams.has('darkpopout');
		const parentOk = cur.searchParams.get('parent') === parent;
		if (hasDark && parentOk) return;
	  } catch {
		// If parsing fails, we’ll set it below
	  }

	  // Prevent white flash: start transparent, fade in on load
	  chatIframe.style.opacity = '0';
	  chatIframe.style.transition = 'opacity .15s ease';
	  chatIframe.onload = () => { chatIframe.style.opacity = '1'; };

	  // Apply and keep container dark as a safety net
	  chatIframe.src = url;
	  chatIframe.classList.add('twitch-dark-bg');
	  chatIframe.style.background = '#0d1322';
	  chatIframe.style.height = '100%';
	  chatIframe.style.width = '100%';
	  chatIframe.style.display = 'block';
	  // Not required for modern browsers, harmless if left:
	  chatIframe.allowTransparency = 'true';
	}
	  

	function toggleChat() {
	  const open = !document.body.classList.contains('chat-open');
	  if (open) {
		document.body.classList.add('chat-open');
		if (chatWrap) chatWrap.hidden = false;
		// Ensure src is set the first time it’s opened
		setChatSrc();
		// Ensure chat scales vertically on open
		if (chatWrap) chatWrap.style.height = '100%';
		if (chatIframe) chatIframe.style.height = '100%';
	  } else {
		document.body.classList.remove('chat-open');
		if (chatWrap) chatWrap.hidden = true;
	  }
	}
	document.getElementById('btnChat').onclick = toggleChat;

	// --- Mobile layout helper (additions) ---
	(function () {
	  // Set to false if you do NOT want chat to auto-open once on mobile.
	  const AUTO_OPEN_CHAT_ON_MOBILE = true;
	  const MOBILE_MEDIA = window.matchMedia('(max-width: 700px)');
	  let autoOpenedOnce = false;

	  function isMobile() { return MOBILE_MEDIA.matches; }

	  function applyMobileLayout() {
		const mobile = isMobile();
		document.body.classList.toggle('mobile', mobile);

		// On mobile, optionally open chat once so it appears under the video
		if (mobile && AUTO_OPEN_CHAT_ON_MOBILE && !autoOpenedOnce) {
		  autoOpenedOnce = true;
		  try {
			if (!document.body.classList.contains('chat-open')) {
			  document.body.classList.add('chat-open');
			  if (typeof chatWrap !== 'undefined' && chatWrap) chatWrap.hidden = false;
			  // Make sure the iframe URL is set when auto-opening
			  setChatSrc();
			  if (chatWrap) chatWrap.style.height = '100%';
			  if (chatIframe) chatIframe.style.height = '100%';
			}
		  } catch {}
		}
	  }

	  // Run now and on viewport changes
	  applyMobileLayout();
	  MOBILE_MEDIA.addEventListener?.('change', applyMobileLayout);
	  window.addEventListener('resize', applyMobileLayout);
	})();

	// Ensure chat URL is ready even if user never presses the button
	  window.addEventListener('DOMContentLoaded', () => {
		buildBanner();
		setChatSrc();
	});

    // ----- Remap UI + state -----
    const ALL_BUTTONS = ["A","B","X","Y","LB","RB","Back","Start","LS","RS","DPadUp","DPadDown","DPadLeft","DPadRight"];
    const DISABLE_SENTINEL = ""; // maps to "send nothing"
    const REMAP_STORE_KEY = "controlRemapV1";

    function defaultRemap() {
      const m = {};
      ALL_BUTTONS.forEach(n => m[n] = n);
      return m;
    }
    function loadRemap() {
      try {
        const raw = localStorage.getItem(REMAP_STORE_KEY);
        if (!raw) return defaultRemap();
        const obj = JSON.parse(raw);
        // sanity: ensure all keys exist
        ALL_BUTTONS.forEach(n => { if (!(n in obj)) obj[n] = n; });
        return obj;
      } catch { return defaultRemap(); }
    }
    function saveRemap(m) {
      try { localStorage.setItem(REMAP_STORE_KEY, JSON.stringify(m)); } catch {}
    }
    let remap = loadRemap();

    const btnRemap = document.getElementById('btnRemap');
    const remapPanel = document.getElementById('remapPanel');
    const remapGrid = document.getElementById('remapGrid');
    const btnRemapReset = document.getElementById('btnRemapReset');
    const btnRemapClose = document.getElementById('btnRemapClose');

    function buildRemapPanel() {
      remapGrid.innerHTML = "";
      ALL_BUTTONS.forEach(src => {
        const lab = document.createElement('label');
        lab.textContent = src;
        const sel = document.createElement('select');

        // Disabled option
        const optDis = document.createElement('option');
        optDis.value = DISABLE_SENTINEL;
        optDis.textContent = "(Disabled)";
        sel.appendChild(optDis);

        // Options for all virtual targets
        ALL_BUTTONS.forEach(dst => {
          const opt = document.createElement('option');
          opt.value = dst;
          opt.textContent = dst;
          sel.appendChild(opt);
        });

        sel.value = (remap[src] ?? src);
        sel.onchange = () => {
          remap[src] = sel.value;
          saveRemap(remap);
          log(`[REMAP] ${src} -> ${sel.value || "(Disabled)"}`);
        };

        remapGrid.appendChild(lab);
        remapGrid.appendChild(sel);
      });
    }

    function toggleRemapPanel() {
      const willShow = remapPanel.hasAttribute('hidden');
      if (willShow) buildRemapPanel();
      if (willShow) remapPanel.removeAttribute('hidden'); else remapPanel.setAttribute('hidden', "");
    }

    btnRemap.onclick = toggleRemapPanel;
    btnRemapReset.onclick = () => {
      remap = defaultRemap();
      saveRemap(remap);
      buildRemapPanel();
      log("[REMAP] Reset to defaults");
    };
    btnRemapClose.onclick = () => remapPanel.setAttribute('hidden', "");

    // Close when clicking outside
    document.addEventListener('click', (e) => {
      if (!remapPanel.hasAttribute('hidden')) {
        const within = remapPanel.contains(e.target) || btnRemap.contains(e.target);
        if (!within) remapPanel.setAttribute('hidden', "");
      }
    });

    // ----- Video / audio -----
    const vid=document.getElementById('vid'), vol=document.getElementById('vol'), btnMute=document.getElementById('btnMute');
    const overlay=document.getElementById('overlay'), ovText=document.getElementById('ovText'), videoWrap=document.getElementById('videoWrap');

    function ensurePlay(){ const p=vid.play(); if(p&&p.then)p.catch(()=>{}); }
    function updateMuteVisual(){ const muted=vid.muted||vid.volume===0; btnMute.classList.toggle('muted',muted); btnMute.setAttribute('aria-pressed', String(!muted)); }
    function lockAspectFromTrack(track){ try{ const st = track.getSettings?.()||{}; const w = st.width||0, h=st.height||0; if(w>0 && h>0) videoWrap.style.aspectRatio = `${w} / ${h}`; }catch{} }

    let autoUnmuted = false;
    async function firstInteract(){ if(autoUnmuted) return; autoUnmuted = true; try{ const stored = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'30',10))); if(vid.volume===0&&stored>0){ vid.volume=stored/100; vol.value=stored; } vid.muted=false; updateMuteVisual(); ensurePlay(); }catch{} }
    ['pointerdown','keydown'].forEach(ev=>window.addEventListener(ev, firstInteract, {once:true, capture:true}));

    btnMute.onclick=async()=>{ try{ if(vid.muted || vid.volume===0){ vid.muted=false; if (vid.volume===0) { const stored=Math.max(0,Math.min(100,parseInt(localStorage.getItem('viewerVolume')||'30',10)||30)); vid.volume=stored/100; vol.value=stored; } }else{ vid.muted=true; } updateMuteVisual(); ensurePlay(); }catch{} };
    vol.addEventListener('input', ()=>{ const v=Math.max(0,Math.min(100,parseInt(vol.value||'0',10)))/100; vid.volume=v; localStorage.setItem('viewerVolume', String(Math.round(v*100))); if(v>0) vid.muted=false; updateMuteVisual(); ensurePlay(); });
    const initVol = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'0',10))); vol.value = initVol; vid.volume = initVol/100; if(initVol===0) vid.muted=true; updateMuteVisual();

    // Fullscreen
   function toggleFs(){ if(!document.fullscreenElement){ (videoWrap.requestFullscreen||videoWrap.webkitRequestFullscreen||videoWrap.msRequestFullscreen||document.body.requestFullscreen||function(){})?.call(videoWrap); } else { (document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen||function(){})?.call(document); } }
    document.getElementById('btnFullscreen').onclick=toggleFs;
    videoWrap.ondblclick=toggleFs;
    document.addEventListener('fullscreenchange', ()=>{ document.body.classList.toggle('fs-active', !!document.fullscreenElement); });

    document.getElementById('btnDebugger').onclick=()=>{ document.body.classList.toggle('clean'); buildBanner(); };


    // ----- Connection -----
    const params=new URLSearchParams(location.search);
    const relayHost=(params.get('relay')||location.host).replace(/^https?:\/\//,'').replace(/\/+$/,'');
    const wsUrl=`${location.protocol==='https:'?'wss':'ws'}://${relayHost}/ws/viewer`;
    document.getElementById('wsUrl').textContent=wsUrl;
    pill('pRelay','ok','Relay: '+relayHost); pill('pTransport','ok','Transport: WebRTC');
	
    // --- TURN support: fetch ICE servers from relay.json; allow ?relayOnly=1 to force TURN ---
    const forceRelay = params.get('relayOnly') === '1';
    const proto = (location.protocol === 'https:') ? 'https' : 'http';
    async function getIceServers(){
      const fallback=[{urls:['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478']}];
      try{
        const r = await fetch(`${proto}://${relayHost}/relay.json`, {
          cache: 'no-store',
          headers: { 'ngrok-skip-browser-warning': '1' }
        });
        const j = await r.json();
        if (Array.isArray(j.ice_servers) && j.ice_servers.length) return j.ice_servers;
      }catch(e){ try{ log('ICE fetch failed, using fallback STUN: '+e);}catch{} }
      return fallback;
    }

    let pc, ws, dc, viewerID=null, restarting=false, hbTimer=null, stallTimer=null;
    let retryDelay = 700;
    const inbound=new MediaStream();

    // --- Connection lost/reconnect overlay logic ---
    let isDisconnected = false;
    function handleDisconnect(reason) {
      if (isDisconnected) return;
      isDisconnected = true;
      log("[CONNECTION LOST] " + reason);
      // Remove any old overlay
      if (document.getElementById('lostConnectionOverlay')) {
        document.getElementById('lostConnectionOverlay').remove();
      }
      // Create overlay
      const overlay = document.createElement('div');
      overlay.id = 'lostConnectionOverlay';
      overlay.innerHTML = `
        <button class="footer-eye-btn" tabindex="-1" aria-label="Animated Eye" style="margin-bottom:1.4em;">
          <svg class="eye-svg" viewBox="0 0 120 80" width="54" height="38">
            <ellipse class="eyeball" cx="60" cy="40" rx="28" ry="18" stroke="#e5e5e5" stroke-width="3" fill="#181818"/>
            <ellipse class="iris" cx="60" cy="40" rx="10" ry="10" fill="#e5e5e5"/>
            <ellipse class="pupil" cx="60" cy="40" rx="5" ry="5" fill="#1a1a1a"/>
          </svg>
        </button>
        <div id="lostConnectionMsg">
          Connection to stream host lost.<br>
          Please reload or <button id="reconnectBtn">Reconnect</button>
        </div>
        <div id="reconnectCountdown">Auto-reloading in <span id="reconnectCount">5</span> seconds...</div>
      `;
      document.body.appendChild(overlay);
      let seconds = 5;
      const countdownEl = document.getElementById('reconnectCount');
      const timer = setInterval(() => {
        seconds--;
        if (countdownEl) countdownEl.textContent = seconds;
        if (seconds <= 0) {
          clearInterval(timer);
          location.reload();
        }
      }, 1000);
      document.getElementById('reconnectBtn').onclick = () => location.reload();
    }

    // --- End overlay logic ---

    async function startViewer(){
      log('WS URL → '+wsUrl); pill('pWs','','WS: connecting'); showOverlay('Connecting…');

      const iceServers = await getIceServers();
      const pcCfg = { iceServers, bundlePolicy:'max-bundle' };
      if (forceRelay) pcCfg.iceTransportPolicy = 'relay';
      pc=new RTCPeerConnection(pcCfg);
      const vTrans=pc.addTransceiver('video',{direction:'recvonly'}); pc.addTransceiver('audio',{direction:'recvonly'});

      try{
        const caps=RTCRtpReceiver.getCapabilities('video'); const codecs=(caps&&caps.codecs)||[];
        const h264=codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('h264'));
        const vp8 =codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('vp8'));
        const prefs=[...h264,...vp8];
        if(vTrans&&vTrans.setCodecPreferences&&prefs.length){ vTrans.setCodecPreferences(prefs); }
      }catch{}

      dc=pc.createDataChannel('inputs'); dc.onopen=()=>pill('pDc','ok','DC: open'); dc.onclose=()=>pill('pDc','bad','DC: closed');

      pc.ontrack=(e)=>{
        if(!inbound.getTracks().includes(e.track)) inbound.addTrack(e.track);
        if(vid.srcObject!==inbound) vid.srcObject=inbound;
        pill('pAv','ok','A/V: attached'); hideOverlay(); ensurePlay();
        if(e.track.kind==='video'){ lockAspectFromTrack(e.track); retryDelay = 700; }
      };
      pc.oniceconnectionstatechange=()=>{ const s=pc.iceConnectionState; pill('pIce', (s==='connected'||s==='completed')?'ok':(s==='failed'?'bad':'warn'), 'ICE: '+s);
        if (['disconnected','failed','closed'].includes(s)) { handleDisconnect("ICE " + s); }
      };
      pc.onconnectionstatechange=()=>{ const s=pc.connectionState; pill('pPc', s==='connected'?'ok':(s==='failed'?'bad':'warn'), 'Peer: '+s);
        if (['disconnected','failed','closed'].includes(s)) { handleDisconnect("PeerConnection " + s); }
      };

      ws=new WebSocket(wsUrl);
      ws.onopen=()=>{ log('WS open'); pill('pWs','ok','WS: open'); ws.send(JSON.stringify({type:'hello',role:'viewer'})); startHeartbeats(); };
      ws.onerror=()=>{ handleDisconnect("WebSocket error"); };
      ws.onclose=()=>{ handleDisconnect("WebSocket closed"); };
      ws.onmessage=async(ev)=>{ const msg=JSON.parse(ev.data); if(msg.type==='pong') return;
        if(msg.type==='welcome'){ viewerID=msg.viewer_id; const offer=await pc.createOffer(); await pc.setLocalDescription(offer); ws.send(JSON.stringify({type:'offer',viewer:viewerID,sdp:{type:offer.type,sdp:offer.sdp}})); }
        else if(msg.type==='answer'){ await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp)); log('Answer applied'); pill('pSig','ok','Signaling: answer'); hideOverlay(); ensurePlay(); }
        else if(msg.type==='candidate'){ try{ await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); }catch(e){ log('ICE add err '+e); } }
      };

      if (dc) {
        dc.onclose = () => handleDisconnect("DataChannel closed");
        dc.onerror = () => handleDisconnect("DataChannel error");
      }
    }

    function showOverlay(text){ if(text) ovText.textContent=text; overlay.hidden=false; }
    function hideOverlay(){ overlay.hidden=true; }
    function startHeartbeats(){ if(hbTimer) clearInterval(hbTimer); hbTimer=setInterval(()=>{ try{ if(ws&&ws.readyState===1) ws.send(JSON.stringify({type:'ping',viewer:viewerID})); if(dc&&dc.readyState==='open') dc.send(JSON.stringify({type:'ping',viewer:viewerID})); }catch{} }, 2500); }
    function restartSoon(){ if(restarting) return; restarting=true; showOverlay('Reconnecting…'); setTimeout(()=>{ restarting=false; stopSession(); startViewer(); retryDelay=Math.min(retryDelay*1.5, 5000); }, retryDelay); }
    function stopSession(){ try{ if(hbTimer) clearInterval(hbTimer); hbTimer=null; }catch{} try{ if(stallTimer) clearInterval(stallTimer); stallTimer=null; }catch{} try{ dc?.close(); }catch{} try{ ws?.close(); }catch{} try{ pc?.close(); }catch{} }

    function startStallDetector(){
      if(stallTimer) clearInterval(stallTimer);
      let vBytesPrev=0, lastOk=performance.now();
      stallTimer=setInterval(async()=>{
        if(!pc) return;
        try{
          const stats = await pc.getStats(); let vBytes=0;
          stats.forEach(r=>{ if(r.type==='inbound-rtp' && r.kind==='video' && !r.isRemote) vBytes += (r.bytesReceived||0); });
          const now=performance.now();
          if(vBytes>vBytesPrev){ vBytesPrev=vBytes; lastOk=now; pill('pAv','ok','A/V: receiving'); hideOverlay(); ensurePlay(); }
          else if(now-lastOk>4500){ showOverlay('Reconnecting…'); restartSoon(); }
          else if(now-lastOk>2000){ pill('pAv','warn','A/V: stalled'); showOverlay('Buffering…'); }
        }catch{}
      }, 1000);
    }

    // Inputs (send only)
     let inputTimer = null, lastPayload = '';
    const buttonMap = {0:'A',1:'B',2:'X',3:'Y',4:'LB',5:'RB',8:'Back',9:'Start',10:'LS',11:'RS',12:'DPadUp',13:'DPadDown',14:'DPadLeft',15:'DPadRight'};

    // --- Gamepad + Keyboard input → send to host (additive, non-breaking) ---
    const KEY_AXIS = { // simple keyboard axis helpers (WASD / Arrows)
      ArrowUp:   {i:1, v:-1}, ArrowDown: {i:1, v: 1}, ArrowLeft:{i:0, v:-1}, ArrowRight:{i:0, v: 1},
      KeyW:      {i:1, v:-1}, KeyS:      {i:1, v: 1}, KeyA:     {i:0, v:-1}, KeyD:       {i:0, v: 1},
    };
    const KEY_BUTTON = { // minimal keyboard → virtual buttons
      Space:'A', KeyJ:'B', KeyK:'X', KeyL:'Y',
      KeyQ:'LB', KeyE:'RB',
      Enter:'Start', Backspace:'Back',
      KeyU:'LS', KeyI:'RS',
      KeyT:'DPadUp', KeyG:'DPadDown', KeyF:'DPadLeft', KeyH:'DPadRight',
    };
    const downKeys = new Set();

    window.addEventListener('keydown', (e)=>{
      if (e.repeat) return;
      downKeys.add(e.code);
    }, {passive:true});
    window.addEventListener('keyup', (e)=>{
      downKeys.delete(e.code);
    }, {passive:true});

    function clamp1(x){ x = Number(x)||0; return x<-1?-1:x>1?1:x; }
    function deadzone(x, dz=0.10){
      const s = Math.sign(x); const a = Math.abs(x);
      if (a <= dz) return 0;
      return clamp1(s * (a - dz) / (1 - dz));
    }

    function readKeyboardAxes(){
      // Left stick only for keyboard
      let lx = 0, ly = 0;
      for (const code of downKeys) {
        const ax = KEY_AXIS[code];
        if (!ax) continue;
        if (ax.i === 0) lx += ax.v;
        else if (ax.i === 1) ly += ax.v;
      }
      lx = Math.max(-1, Math.min(1, lx));
      ly = Math.max(-1, Math.min(1, ly));
      return [lx, ly, 0, 0];
    }

    function readKeyboardButtons(){
      const b = new Set();
      for (const code of downKeys) {
        const name = KEY_BUTTON[code];
        if (name) b.add(name);
      }
      // DPad from explicit keys overrides axis mapping; already handled in KEY_BUTTON
      return b;
    }

    function getFirstGamepad(){
      const gps = navigator.getGamepads ? navigator.getGamepads() : [];
      for (let i=0;i<gps.length;i++){
        const g=gps[i]; if (g && g.connected) return g;
      }
      return null;
    }

    function readGamepadState(){
      const g = getFirstGamepad();
      if (!g) return null;
      // Axes: try standard mapping: [lx,ly,rx,ry]; fallbacks if shorter
      const ax = [
        clamp1(g.axes?.[0] ?? 0),
        clamp1(g.axes?.[1] ?? 0),
        clamp1(g.axes?.[2] ?? 0),
        clamp1(g.axes?.[3] ?? 0),
      ];
      const axes = [
        deadzone(ax[0]), deadzone(ax[1]),
        deadzone(ax[2]), deadzone(ax[3]),
      ];
      // Buttons into names (pressed)
      const btnNames = new Set();
      for (let i=0;i<(g.buttons?.length||0);i++){
        const pressed = !!g.buttons[i]?.pressed;
        if (!pressed) continue;
        const name = buttonMap[i];
        if (name) btnNames.add(name);
      }
      // Triggers (prefer analog if available)
      let LT = 0, RT = 0;
      if (g.buttons?.[6]) LT = clamp1(g.buttons[6].value || (g.buttons[6].pressed?1:0));
      if (g.buttons?.[7]) RT = clamp1(g.buttons[7].value || (g.buttons[7].pressed?1:0));
      return { axes, buttons: btnNames, LT, RT };
    }

    function applyRemapToButtons(srcButtonsSet){
      // srcButtonsSet: Set of source names; map via remap object -> dest set
      const out = new Set();
      srcButtonsSet.forEach(src=>{
        const dst = remap[src] ?? src;
        if (dst && dst.length) out.add(dst); // DISABLE_SENTINEL === "" => skip
      });
      return Array.from(out.values());
    }

    function currentInputSnapshot(){
      // Merge gamepad + keyboard
      const gp = readGamepadState();
      const kbAxes = readKeyboardAxes();
      const kbButtons = readKeyboardButtons();

      // Axes: prefer gamepad; if none, use keyboard (left stick)
      let axes = gp ? gp.axes.slice(0,4) : [0,0,0,0];
      if (!gp) {
        axes[0] = kbAxes[0];
        axes[1] = kbAxes[1];
      }

      // Buttons: union of both
      const btnSet = new Set(gp ? gp.buttons : []);
      kbButtons.forEach(b=>btnSet.add(b));

      // Triggers
      const LT = gp ? Math.max(0, Math.min(1, gp.LT||0)) : 0;
      const RT = gp ? Math.max(0, Math.min(1, gp.RT||0)) : 0;

      // Apply user remap
      const buttons = applyRemapToButtons(btnSet);

      return { buttons, axes, triggers:{LT, RT} };
    }

    function payloadEquals(a,b){
      if (!a || !b) return false;
      if (a.buttons.length !== b.buttons.length) return false;
      for (let i=0;i<a.buttons.length;i++) if (a.buttons[i]!==b.buttons[i]) return false;
      for (let i=0;i<4;i++) if (Math.abs((a.axes?.[i]||0)-(b.axes?.[i]||0))>0.001) return false;
      if (Math.abs((a.triggers?.LT||0)-(b.triggers?.LT||0))>0.001) return false;
      if (Math.abs((a.triggers?.RT||0)-(b.triggers?.RT||0))>0.001) return false;
      return true;
    }

    function sendInput(obj){
      const json = JSON.stringify(obj);
      // Prefer data channel when available
      try {
        if (dc && dc.readyState === 'open') {
          dc.send(json);
          return;
        }
      } catch {}
      try {
        if (ws && ws.readyState === 1) {
          ws.send(json);
        }
      } catch {}
    }

    function startInputLoop(){
      // 30Hz-ish loop using rAF + time gating
      let lastTs = 0;
      function step(ts){
        if (!pc) { requestAnimationFrame(step); return; }
        if (ts - lastTs < 33) { requestAnimationFrame(step); return; }
        lastTs = ts;

        const snap = currentInputSnapshot();
        const payload = {
          type:'input',
          buttons: snap.buttons,
          axes: snap.axes,
          triggers: snap.triggers
        };

        // Dedup to reduce spam
        if (!payloadEquals(payload, lastPayload)) {
          lastPayload = payload;
          sendInput(payload);
        }
        requestAnimationFrame(step);
      }
      if (!inputTimer) {
        inputTimer = true; // sentinel (we use rAF not setInterval)
        requestAnimationFrame(step);
      }
    }

    // ----- Logs download -----
    document.getElementById('btnDownloadLogs').onclick = ()=>{
      try{
        const blob = new Blob([logEl.textContent || ''], {type:'text/plain;charset=utf-8'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `viewer-logs-${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 50);
      }catch(e){}
    };

    // ----- Boot -----
    window.addEventListener('load', ()=>{
      try { setChatSrc(); } catch {}
      try { buildBanner(); } catch {}
      try { startViewer(); } catch {}
      try { startStallDetector(); } catch {}
      try { startInputLoop(); } catch {}
    });
  </script>
</body>
</html>
