<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts for banner + buttons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0e0e10; --panel:#18181b; --edge:#23232a; --fg:#efeff1; --muted:#b9b9c2; --accent:#9146ff; --accent-2:#772ce8; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; --chat-w:360px; --banner-h:36px; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans";}
    button, input, select, label { font-family:"Orbitron", system-ui, sans-serif; letter-spacing:0.4px; }

    /* Banner */
    #brandBanner{position:sticky; top:0; z-index:50; height:var(--banner-h); background:linear-gradient(90deg,rgba(12,10,22,.9),rgba(20,14,38,.9)); border-bottom:1px solid #241d3a; overflow:hidden; display:flex; align-items:center;}
    #brandTrack{display:flex; gap:40px; align-items:center; white-space:nowrap; will-change:transform; animation:scrollX 26s linear infinite}
    #brandTrack .item{font-family:"Orbitron",system-ui,sans-serif;font-size:14px;letter-spacing:1.4px;line-height:1;color:#e9e2ff;text-shadow:0 0 12px rgba(145,70,255,.55),0 0 2px rgba(145,70,255,.9);display:flex;align-items:center;gap:10px}
    .dot{display:inline-block;width:7px;height:7px;border-radius:50%;background:var(--accent);box-shadow:0 0 10px var(--accent)}
    @keyframes scrollX{0%{transform:translateX(0)}100%{transform:translateX(-50%)}}

    /* Debug header (hidden in clean) */
    header{display:flex;align-items:center;gap:8px;padding:8px 14px;background:#1f1f23;border-bottom:1px solid var(--edge);position:sticky;top:var(--banner-h);z-index:10;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;line-height:14px;background:#2a2a32;border:1px solid #3a3a4a;color:#cfd3df}
    .pill.ok{background:#15321f;border-color:#1e6a33;color:#a5e7b9}
    .pill.warn{background:#3a2a18;border-color:#b57a28;color:#ffd89a}
    .pill.bad{background:#3a1a1a;border-color:#b52828;color:#ff9a9a}
    #wsUrl{margin-left:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:#9fb2d1}

    /* Layout */
    main{display:grid;grid-template-columns:1fr;gap:10px;padding:12px}
    body.chat-open #sidePanel{display:grid}
    body.chat-open main{ grid-template-columns:1fr var(--chat-w); }

    /* Stable video box sizing */
    #videoWrap{position:relative;background:#0f1320;border:1px solid #1d2436;border-radius:8px;overflow:hidden;aspect-ratio:16/9;min-height:360px;contain:layout paint}
    #vid{width:100%;height:100%;display:block;background:#000;object-fit:contain;aspect-ratio:inherit}
    #overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(180deg,rgba(10,14,21,.65),rgba(10,14,21,.75));pointer-events:none;transition:opacity .15s}
    #overlay[hidden]{display:none}
    #ovText{font-size:16px;color:#c6d3ea;text-shadow:0 1px 2px rgba(0,0,0,.6)}

    /* Controls */
    #controls{display:flex;flex-wrap:wrap;gap:10px;padding:10px 0;align-items:center}
    button,input,select{border-radius:8px;border:1px solid #2a2a32;color:#f3edff;background:#1e123a}
    button.accent{background:linear-gradient(180deg,var(--accent),var(--accent-2));border-color:#5f37d6;color:#fff;box-shadow:0 6px 18px rgba(145,70,255,.25),inset 0 0 0 1px rgba(255,255,255,.05)}
    button.accent:hover{filter:brightness(1.05)} button.accent:active{transform:translateY(1px)}
    input[type=range]{appearance:none;height:6px;background:#1d1931;border:1px solid #2b2350;width:160px;border-radius:999px}
    input[type=range]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);box-shadow:0 0 8px rgba(145,70,255,.55);border:1px solid #fff1}

    /* Icons */
    #iconRow{display:flex;align-items:center;gap:8px}
    #btnMute{display:flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:8px;background:#1a1430;border:1px solid #2a2050;cursor:pointer}
    #btnMute svg{width:20px;height:20px;fill:var(--accent);transition:opacity .15s,filter .15s}
    #btnMute.muted svg{opacity:.45;filter:grayscale(.4) brightness(.8)}
    #padIconWrap{display:flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:8px;background:#141a12;border:1px solid #1f2b19}
    #padIconWrap.off{background:#1b1b1e;border-color:#2a2a32}
    #padIcon{width:22px;height:22px}
    #padIcon.off path{fill:#8a8a98}
    #padIcon.on path{fill:var(--ok);filter:drop-shadow(0 0 6px rgba(34,197,94,.65))}

    /* Side panel */
    #sidePanel{display:none;grid-template-rows:min-content 1fr;gap:10px}
    #chatWrap{border:1px solid #1d2436;border-radius:8px;overflow:hidden;background:#0d1322;min-height:320px}
    #chatIframe{width:100%;height:100%;min-height:320px;border:0;background:#0d1322}

    /* Logs (debugger only) */
    #logPanel{display:grid;grid-template-rows:min-content 1fr;border:1px solid #1d2436;border-radius:8px;overflow:hidden}
    #logHeader{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:#121824;border-bottom:1px solid #1d2436}
    #log{margin:0;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.4;background:#0d1322;white-space:pre;overflow:auto}

    /* Footer */
    footer{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px;color:#7a8fb2;border-top:1px solid #20283a;background:#0e1524}
    #footerRight{margin-left:auto;display:flex;align-items:center;gap:8px}
    #btnDebugger{padding:6px 10px;font-size:12px;opacity:.9}

    /* Clean vs Debugger */
    body.clean header{display:none!important}
    body.clean #logPanel{display:none!important}
    body.clean #controls>*{display:none}
    body.clean #btnChat, body.clean #volumeWrap, body.clean #btnFullscreen, body.clean #iconRow{display:flex}
    body:not(.clean) #btnFullscreen{display:none}
    .fs-active #videoWrap{box-shadow:0 0 0 2px var(--accent) inset}
  </style>
</head>

<body class="clean">
  <!-- Banner with dynamic stats -->
  <div id="brandBanner" role="banner" aria-label="Credits banner"><div id="brandTrack"></div></div>

  <!-- Debug header -->
  <header>
    <span id="pRelay" class="pill">Relay</span><span id="pWs" class="pill">WS</span><span id="pSig" class="pill">Signaling</span><span id="pIce" class="pill">ICE</span><span id="pDtls" class="pill">DTLS</span><span id="pPc" class="pill">Peer</span><span id="pDc" class="pill">DC</span><span id="pAv" class="pill">A/V</span><span id="pTransport" class="pill">Transport</span>
    <span id="wsUrl" class="pill">ws://</span>
  </header>

  <main>
    <section>
      <div id="videoWrap">
        <video id="vid" playsinline muted autoplay></video>
        <div id="overlay"><div id="ovText">Connecting…</div></div>
      </div>
      <div id="controls">
        <button id="btnChat" class="accent" title="Toggle Twitch chat">Twitch Chat</button>
        <div id="volumeWrap" style="display:flex;align-items:center;gap:8px">
          <label for="vol" style="opacity:.8">Volume</label>
          <input id="vol" type="range" min="0" max="100" value="0" />
          <div id="iconRow">
            <button id="btnMute" class="muted" aria-label="Toggle mute" title="Toggle audio">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3 10v4h4l5 4V6L7 10H3z"></path>
                <path d="M14.5 12a4.5 4.5 0 0 0-1.2-3.1l1.4-1.4A6.5 6.5 0 0 1 16.5 12a6.5 6.5 0 0 1-1.8 4.5l-1.4-1.4A4.5 4.5 0 0 0 14.5 12z"></path>
                <path d="M18 12a8 8 0 0 0-2.1-5.4l1.4-1.4A10 10 0 0 1 20 12a10 10 0 0 1-2.7 6.8l-1.4-1.4A8 8 0 0 0 18 12z"></path>
              </svg>
            </button>
            <div id="padIconWrap" class="off" title="Controller status">
              <svg id="padIcon" class="off" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 8h10a4 4 0 0 1 3.8 2.7l1.1 3.2A3 3 0 0 1 19 18h-1.7l-1.8-2H8.5l-1.8 2H5A3 3 0 0 1 2.1 13.9l1.1-3.2A4 4 0 0 1 7 8zm3 2H8v2H6v2h2v2h2v-2h2v-2h-2v-2zm8 1.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm-3-1a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"></path>
              </svg>
            </div>
          </div>
        </div>
        <button id="btnFullscreen" class="accent" title="Fullscreen">Fullscreen</button>
        <button id="btnDownloadLogs">Download logs</button>
        <input id="chatChannel" type="text" placeholder="Twitch channel" style="min-width:160px"/>
        <button id="btnSetChannel">Set chat channel</button>
      </div>
    </section>

    <aside id="sidePanel">
      <div id="chatWrap" hidden><iframe id="chatIframe" title="Twitch chat"></iframe></div>
      <div id="logPanel"><div id="logHeader"><strong>Viewer logs</strong><span style="opacity:.7">Use “Download logs”.</span></div><pre id="log"></pre></div>
    </aside>
  </main>

  <footer>
    <small>Status indicators reflect last known state and auto-recover triggers.</small>
    <div id="footerRight"><button id="btnDebugger" title="Toggle debug UI">Debugger</button></div>
  </footer>

  <script>
    const logEl=document.getElementById('log'); function log(m){const t=new Date().toLocaleTimeString(); logEl.textContent+=`[${t}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight;}
    function pill(id,cls,text){const el=document.getElementById(id); if(!el) return; el.className='pill '+(cls||''); if(text) el.textContent=text;}

    // ----- Banner stats ( robust ) -----
    const PROJECT_START = new Date('2025-09-29T00:00:00Z');
    const brandTrack = document.getElementById('brandTrack');
    function getLangs(){ return ['Python','HTML','CSS','JavaScript']; }
    function readChatCount(){
      const url = new URL(location.href);
      const fromUrl = url.searchParams.get('copilot_chats');
      if(fromUrl && /^\d+$/.test(fromUrl)){ localStorage.setItem('copilotChatsTotal', fromUrl); return parseInt(fromUrl,10); }
      const stored = localStorage.getItem('copilotChatsTotal');
      return stored && /^\d+$/.test(stored) ? parseInt(stored,10) : 0; // default 0 not —
    }
    async function fetchLinesRaw(rawUrl){
      try{ const r=await fetch(rawUrl,{cache:'no-store',mode:'cors'}); if(!r.ok) throw 0; const t=await r.text(); return t.split(/\r?\n/).length; }catch{return 0}
    }
    async function fetchLinesAPI(owner,repo,path){
      try{
        const api=`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=main`;
        const r=await fetch(api,{cache:'no-store'}); if(!r.ok) throw 0;
        const j=await r.json();
        if(j.content && j.encoding==='base64'){
          const txt = atob(j.content.replace(/\n/g,''));
          return txt.split(/\r?\n/).length;
        }
        if(j.download_url){ return fetchLinesRaw(j.download_url); }
        return 0;
      }catch{return 0}
    }
    async function calcLoc(){
      const url = new URL(location.href);
      const locParam = url.searchParams.get('loc');
      if(locParam && /^\d+$/.test(locParam)) return parseInt(locParam,10);
      // Try raw, then API
      const owner='LunarisTHICC', repo='offline';
      const paths=['Viewer.html','Doppelganger.py'];
      let total=0;
      for(const p of paths){
        const raw=`https://raw.githubusercontent.com/${owner}/${repo}/main/${p}?t=${Date.now()}`;
        let n = await fetchLinesRaw(raw);
        if(n===0) n = await fetchLinesAPI(owner,repo,p);
        total += n;
      }
      return total; // may be 0 if offline
    }
    function bannerItem(text){
      const span = document.createElement('span');
      span.className = 'item';
      const d1 = document.createElement('i'); d1.className='dot';
      const d2 = document.createElement('i'); d2.className='dot';
      const label = document.createElement('span'); label.textContent = text;
      span.appendChild(d1); span.appendChild(label); span.appendChild(d2);
      return span;
    }
    async function buildBanner(){
      brandTrack.innerHTML = '';
      const now=new Date(); const days=Math.max(1, Math.floor((now-PROJECT_START)/86400000));
      const hh=String(now.getHours()).padStart(2,'0'), mm=String(now.getMinutes()).padStart(2,'0');
      const totalChats = readChatCount();
      let loc = await calcLoc();
      if(!Number.isFinite(loc) || loc<0) loc = 0;
      const items = [
        `Made by JunkfoodJon with CoPilot and GitHub`,
        `How long this project took: ${days} day${days!==1?'s':''}`,
        `Lines of code used (Viewer + Doppelganger): ${loc}`,
        `Languages used: ${getLangs().join(', ')}`,
        `Total chats with Copilot: ${totalChats}`,
        `Local time: ${hh}:${mm}`,
        `Viewer mode: ${document.body.classList.contains('clean') ? 'Clean' : 'Debugger'}`
      ];
      const row = document.createDocumentFragment();
      for(let k=0;k<2;k++){ for(const t of items){ row.appendChild(bannerItem(t)); } }
      brandTrack.appendChild(row);
    }
    buildBanner(); setInterval(buildBanner, 30000);

    // ----- Chat controls -----
    const chatWrap=document.getElementById('chatWrap'), chatIframe=document.getElementById('chatIframe');
    const savedCh=(localStorage.getItem('twitchChatChannel')||'').trim(); if(savedCh) document.getElementById('chatChannel').value = savedCh;
    function setChatSrc(ch){ if(!ch) return; const parent=location.host; chatIframe.src=`https://www.twitch.tv/embed/${encodeURIComponent(ch)}/chat?parent=${parent}`; }
    if(savedCh) setChatSrc(savedCh);
    function toggleChat(){ const opening = !document.body.classList.contains('chat-open'); if(opening){ document.body.classList.add('chat-open'); chatWrap.hidden=false; } else { document.body.classList.remove('chat-open'); chatWrap.hidden=true; } }
    document.getElementById('btnChat').onclick=toggleChat;
    document.getElementById('btnSetChannel').onclick=()=>{ const ch=document.getElementById('chatChannel').value.trim(); if(!ch) return; localStorage.setItem('twitchChatChannel',ch); setChatSrc(ch); document.body.classList.add('chat-open'); chatWrap.hidden=false; };

    // ----- Video + volume/mute + autoplay -----
    const vid=document.getElementById('vid'); const vol=document.getElementById('vol'); const btnMute=document.getElementById('btnMute');
    const padIconWrap=document.getElementById('padIconWrap'); const padIcon=document.getElementById('padIcon');
    const overlay=document.getElementById('overlay'), ovText=document.getElementById('ovText'); const videoWrap=document.getElementById('videoWrap');

    function ensurePlay(){ const p=vid.play(); if(p&&p.then)p.catch(()=>{}); }
    function updateMuteVisual(){ const muted=vid.muted||vid.volume===0; btnMute.classList.toggle('muted',muted); btnMute.setAttribute('aria-pressed', String(!muted)); }

    function lockAspectFromTrack(track){
      try{
        if(!track || !track.getSettings) return;
        const st = track.getSettings(); const w = st.width||0, h = st.height||0;
        if(w>0 && h>0){ videoWrap.style.aspectRatio = `${w} / ${h}`; }
      }catch{}
    }

    let autoUnmuted = false;
    async function firstInteract(){ if(autoUnmuted) return; autoUnmuted = true; try{ const stored = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'30',10))); if(vid.volume===0) { vid.volume = Math.max(0.05, stored/100); vol.value=Math.round(vid.volume*100); } vid.muted=false; await vid.play(); }catch{} updateMuteVisual(); }
    ['pointerdown','keydown'].forEach(ev=>window.addEventListener(ev, firstInteract, {once:true, capture:true}));
    window.addEventListener('gamepadconnected', firstInteract, {once:true});

    btnMute.onclick=async()=>{ try{ if(vid.muted || vid.volume===0){ vid.muted=false; if (vid.volume===0) { const stored=Math.max(0,Math.min(100,parseInt(localStorage.getItem('viewerVolume')||'30',10))); vid.volume=Math.max(0.05, stored/100); vol.value=Math.round(vid.volume*100); } await vid.play(); } else { vid.muted=true; } }catch(e){ log('Autoplay error: '+e.name); } updateMuteVisual(); };
    vol.addEventListener('input', ()=>{ const v=Math.max(0,Math.min(100,parseInt(vol.value||'0',10)))/100; vid.volume=v; localStorage.setItem('viewerVolume', String(Math.round(v*100))); if(v>0) vid.muted=false; updateMuteVisual(); });
    const initVol = Math.max(0, Math.min(100, parseInt(localStorage.getItem('viewerVolume')||'0',10))); vol.value = initVol; vid.volume = initVol/100; if(initVol===0) vid.muted=true; updateMuteVisual();

    const btnFullscreen=document.getElementById('btnFullscreen');
    btnFullscreen.onclick=()=>{ if(!document.fullscreenElement){ (videoWrap.requestFullscreen||document.body.requestFullscreen||function(){})(); } else { document.exitFullscreen?.(); } };
    document.addEventListener('fullscreenchange', ()=>{ document.body.classList.toggle('fs-active', !!document.fullscreenElement); });

    document.getElementById('btnDebugger').onclick=()=>{ document.body.classList.toggle('clean'); buildBanner(); };

    // ----- Connection + robust reconnect -----
    const params=new URLSearchParams(location.search);
    const relayHost=(params.get('relay')||location.host).replace(/^https?:\/\//,'').replace(/\/+$/,'');
    const wsUrl=`${location.protocol==='https:'?'wss':'ws'}://${relayHost}/ws/viewer`;
    document.getElementById('wsUrl').textContent=wsUrl;
    pill('pRelay','ok','Relay: '+relayHost); pill('pTransport','ok','Transport: WebRTC');

    let pc, ws, dc, viewerID=null, restarting=false, hbTimer=null, stallTimer=null;
    let retryDelay = 700;
    const inbound=new MediaStream();

    async function iceRestart(){
      try{
        if(!pc || !ws || ws.readyState!==1) return false;
        const offer = await pc.createOffer({iceRestart:true});
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({type:'offer',viewer:viewerID,sdp:{type:offer.type,sdp:offer.sdp}}));
        log('ICE restart attempt sent');
        return true;
      }catch(e){ log('ICE restart error'); return false; }
    }

    function applyLowPlayoutDelay(){
      try{
        pc.getReceivers?.().forEach(r=>{
          try{ r.playoutDelayHint = 0.06; }catch{}
        });
      }catch{}
    }

    function startViewer(){
      log('WS URL → '+wsUrl); pill('pWs','','WS: connecting'); showOverlay('Connecting…');

      pc=new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302','stun:global.stun.twilio.com:3478']}], bundlePolicy:'max-bundle'});
      const vTrans=pc.addTransceiver('video',{direction:'recvonly'}); pc.addTransceiver('audio',{direction:'recvonly'});

      try{
        const want=(params.get('codec')||'').toLowerCase();
        const caps=RTCRtpReceiver.getCapabilities('video'); const codecs=(caps&&caps.codecs)||[];
        const h264=codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('h264'));
        const vp8 =codecs.filter(c=>(c.mimeType||'').toLowerCase().includes('vp8'));
        const prefs = want==='vp8'?vp8 : want==='h264'?h264 : [...h264,...vp8];
        if(vTrans&&vTrans.setCodecPreferences&&prefs.length){ vTrans.setCodecPreferences(prefs); log('Codec preference set: H.264 first, VP8 fallback'); }
      }catch{}

      dc=pc.createDataChannel('inputs'); dc.onopen=()=>pill('pDc','ok','DC: open'); dc.onclose=()=>pill('pDc','bad','DC: closed');

      pc.ontrack=(e)=>{
        if(!inbound.getTracks().includes(e.track)) inbound.addTrack(e.track);
        if(vid.srcObject!==inbound) vid.srcObject=inbound;
        pill('pAv','ok','A/V: attached'); hideOverlay(); ensurePlay();
        if(e.track.kind==='video'){ lockAspectFromTrack(e.track); retryDelay = 700; }
        applyLowPlayoutDelay();
      };
      pc.oniceconnectionstatechange=async()=>{
        const s=pc.iceConnectionState;
        pill('pIce', (s==='connected'||s==='completed')?'ok':(s==='failed'?'bad':'warn'), 'ICE: '+s);
        if(s==='disconnected'){ await iceRestart(); }
        if(s==='failed'){ showOverlay('Reconnecting…'); restartSoon(); }
      };
      pc.onconnectionstatechange=()=>{ const s=pc.connectionState; pill('pPc', s==='connected'?'ok':(s==='failed'?'bad':'warn'), 'Peer: '+s); pill('pDtls', s==='connected'?'ok':(s==='failed'?'bad':'warn'), 'DTLS: '+s); if(s==='failed'||s==='closed'){ showOverlay('Reconnecting…'); restartSoon(); } };
      pc.onicecandidate=(ev)=>{ if(ev.candidate && viewerID && ws?.readyState===1){ ws.send(JSON.stringify({type:'candidate',viewer:viewerID,candidate:{candidate:ev.candidate.candidate,sdpMid:ev.candidate.sdpMid,sdpMLineIndex:ev.candidate.sdpMLineIndex}})); } };

      ws=new WebSocket(wsUrl);
      ws.onopen=()=>{ log('WS open'); pill('pWs','ok','WS: open'); ws.send(JSON.stringify({type:'hello',role:'viewer'})); startHeartbeats(); };
      ws.onerror=()=>{ log('WS error'); pill('pWs','bad','WS: error'); restartSoon(); };
      ws.onclose=()=>{ log('WS closed'); pill('pWs','bad','WS: closed'); restartSoon(); };
      ws.onmessage=async(ev)=>{ const msg=JSON.parse(ev.data); if(msg.type==='pong') return;
        if(msg.type==='welcome'){ viewerID=msg.viewer_id; const offer=await pc.createOffer(); await pc.setLocalDescription(offer); ws.send(JSON.stringify({type:'offer',viewer:viewerID,sdp:{type:offer.type,sdp:offer.sdp}})); pill('pSig','warn','Signaling: offer'); }
        else if(msg.type==='answer'){ await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp)); log('Answer applied'); pill('pSig','ok','Signaling: answer'); hideOverlay(); ensurePlay(); }
        else if(msg.type==='candidate'){ try{ await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); }catch(e){ log('ICE add err '+e); } }
      };

      startStallDetector();
    }

    function showOverlay(text){ if(text) ovText.textContent=text; overlay.hidden=false; }
    function hideOverlay(){ overlay.hidden=true; }
    function startHeartbeats(){ if(hbTimer) clearInterval(hbTimer); hbTimer=setInterval(()=>{ try{ if(ws&&ws.readyState===1) ws.send(JSON.stringify({type:'ping',viewer:viewerID})); if(dc&&dc.readyState==='open') dc.send(JSON.stringify({type:'ping'})); }catch{} }, 12000); }
    function restartSoon(){ if(restarting) return; restarting=true; showOverlay('Reconnecting…'); setTimeout(()=>{ restarting=false; stopSession(); startViewer(); retryDelay=Math.min(retryDelay*1.5, 5000); }, retryDelay); }
    function stopSession(){ try{ if(hbTimer) clearInterval(hbTimer); hbTimer=null; }catch{} try{ if(stallTimer) clearInterval(stallTimer); stallTimer=null; }catch{} try{ dc?.close(); }catch{} try{ ws?.close(); }catch{} try{ pc?.close(); }catch{} vid.srcObject=null; dc=ws=pc=null; }

    function startStallDetector(){
      if(stallTimer) clearInterval(stallTimer);
      let vBytesPrev=0, lastOk=performance.now();
      stallTimer=setInterval(async()=>{
        if(!pc) return;
        try{
          const stats = await pc.getStats(); let vBytes=0;
          stats.forEach(r=>{ if(r.type==='inbound-rtp' && r.kind==='video' && !r.isRemote) vBytes += (r.bytesReceived||0); });
          const now=performance.now();
          if(vBytes>vBytesPrev){ vBytesPrev=vBytes; lastOk=now; pill('pAv','ok','A/V: receiving'); hideOverlay(); ensurePlay(); }
          else if(now-lastOk>4500){
            const ok = await iceRestart();
            if(!ok || now-lastOk>8000){ pill('pAv','bad','A/V: stalled'); showOverlay('Reconnecting…'); restartSoon(); }
            else { pill('pAv','warn','A/V: restarting ICE…'); showOverlay('Buffering…'); }
          } else if(now-lastOk>2000){ pill('pAv','warn','A/V: stalled'); showOverlay('Buffering…'); }
        }catch{}
      }, 1000);
    }

    // Inputs + presence
    let inputTimer=null,lastPayload=''; const buttonMap={0:'A',1:'B',2:'X',3:'Y',4:'LB',5:'RB',8:'Back',9:'Start',10:'LS',11:'RS',12:'DPadUp',13:'DPadDown',14:'DPadLeft',15:'DPadRight'};
    function sendInput(o){ const s=JSON.stringify(o); if(s===lastPayload) return; lastPayload=s; try{ if(dc&&dc.readyState==='open') dc.send(s); else if(ws&&ws.readyState===1) ws.send(s); }catch{} }
    function setPadPresent(on){ padIconWrap.classList.toggle('off',!on); padIcon.classList.toggle('off',!on); padIcon.classList.toggle('on',!!on); padIconWrap.title=on?"Controller detected":"No controller detected"; }
    function startInputs(){ if(inputTimer) return; let hadPad=false; inputTimer=setInterval(()=>{ const gps=(navigator.getGamepads&&Array.from(navigator.getGamepads()).filter(Boolean))||[]; const gp=gps.find(g=>g&&g.connected)||null; const present=!!gp; if(present!==hadPad){ setPadPresent(present); if(present) firstInteract(); hadPad=present; }
      const buttons=[],axes=[0,0,0,0],triggers={LT:0,RT:0}; if(gp){ gp.buttons.forEach((b,i)=>{ if(b&&b.pressed){ const n=buttonMap[i]; if(n) buttons.push(n); }}); axes[0]=gp.axes[0]||0; axes[1]=gp.axes[1]||0; axes[2]=gp.axes[2]||0; axes[3]=gp.axes[3]||0; if(gp.buttons[6]) triggers.LT=gp.buttons[6].value||0; if(gp.buttons[7]) triggers.RT=gp.buttons[7].value||0; }
      sendInput({type:'input',buttons,axes,triggers}); },33); log('Input sender started'); }
    function stopInputs(){ if(inputTimer){ clearInterval(inputTimer); inputTimer=null; log('Input sender stopped'); } }

    // Start
    startViewer();
    window.addEventListener('load', ()=>{ setTimeout(startInputs,300); document.body.classList.remove('chat-open'); chatWrap.hidden=true; });
    window.addEventListener('beforeunload', ()=>{ stopInputs(); stopSession(); });
  </script>
</body>
</html>
