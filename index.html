<!DOCTYPE html>
<html>
<head>
  <title>Viewer WebRTC Controller</title>
  <style>
    body, html {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background: black; overflow: hidden;
      font-family: monospace; color: #0f0;
    }
    #debug { position: absolute; top: 10px; left: 10px;
             background: rgba(0,0,0,0.7); padding: 6px;
             max-height: 200px; overflow-y: auto; font-size: 12px; }
    #connection-indicator {
      position: absolute; top: 10px; right: 10px;
      width: 16px; height: 16px; border-radius: 50%;
      background-color: gray; border: 2px solid #222;
    }
  </style>
</head>
<body>
  <div id="connection-indicator"></div>
  <div id="debug"></div>

  <script>
    const debugPanel = document.getElementById("debug");
    function log(msg) {
      const p = document.createElement("div");
      p.textContent = msg;
      debugPanel.appendChild(p);
      debugPanel.scrollTop = debugPanel.scrollHeight;
      console.log(msg);
    }

    const connectionIndicator = document.getElementById("connection-indicator");

    // --- Relay signaling setup ---
    const params = new URLSearchParams(window.location.search);
    let relayDomain = params.get("relay") || window.location.hostname + ":8765";
    relayDomain = relayDomain.replace(/^https?:\/\//, "").replace(/\/+$/, "");
    const wsUrl = (relayDomain.includes("localhost") || relayDomain.includes("127.0.0.1"))
      ? `ws://${relayDomain}/viewer`
      : `wss://${relayDomain}/ws/viewer`;

    const ws = new WebSocket(wsUrl);
    let viewerID = null;
    let pc = null;
    let dataChannel = null;

    ws.onopen = () => {
      log("Connected to relay: " + wsUrl);
      connectionIndicator.style.backgroundColor = "limegreen";
      ws.send(JSON.stringify({ type: "hello", role: "viewer" }));
    };

    ws.onmessage = async (event) => {
      const msg = JSON.parse(event.data);
      if (msg.type === "welcome" && msg.viewer_id) {
        viewerID = msg.viewer_id;
        log("Viewer ID: " + viewerID);
        startWebRTC();
      } else if (msg.type === "offer") {
        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({ type: "answer", sdp: answer, viewer: viewerID }));
      } else if (msg.type === "candidate") {
        try {
          await pc.addIceCandidate(msg.candidate);
        } catch (e) {
          log("Error adding ICE candidate: " + e);
        }
      }
    };

    ws.onclose = () => {
      log("Relay disconnected");
      connectionIndicator.style.backgroundColor = "gray";
    };

    function startWebRTC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      // Data channel for inputs
      dataChannel = pc.createDataChannel("inputs");
      dataChannel.onopen = () => log("DataChannel open");
      dataChannel.onclose = () => log("DataChannel closed");

      // ICE candidates → relay
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, viewer: viewerID }));
        }
      };

      // Create offer → relay
      pc.createOffer().then(offer => {
        pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: "offer", sdp: offer, viewer: viewerID }));
      });
    }

    // --- Gamepad polling ---
    const buttonMap = {
      0: "A", 1: "B", 2: "X", 3: "Y",
      4: "LB", 5: "RB",
      8: "Back", 9: "Start",
      10: "LS", 11: "RS",
      12: "DPadUp", 13: "DPadDown",
      14: "DPadLeft", 15: "DPadRight"
    };

    function pollGamepads() {
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
      if (gamepads[0] && viewerID && dataChannel && dataChannel.readyState === "open") {
        const gp = gamepads[0];
        const buttons = [];
        gp.buttons.forEach((btn, i) => {
          if (btn.pressed && i !== 6 && i !== 7 && buttonMap[i]) {
            buttons.push(buttonMap[i]);
          }
        });
        const axes = gp.axes.map(v => parseFloat(v.toFixed(2)));
        const triggers = {
          LT: gp.buttons[6]?.value ?? axes[2] ?? 0.0,
          RT: gp.buttons[7]?.value ?? axes[5] ?? 0.0
        };
        const payload = { viewer: viewerID, buttons, axes, triggers };
        dataChannel.send(JSON.stringify(payload));
      }
      requestAnimationFrame(pollGamepads);
    }

    window.addEventListener("gamepadconnected", (e) => {
      log("Gamepad connected: " + e.gamepad.id);
      pollGamepads();
    });
    window.addEventListener("gamepaddisconnected", (e) => {
      log("Gamepad disconnected: " + e.gamepad.id);
    });
  </script>
</body>
</html>
