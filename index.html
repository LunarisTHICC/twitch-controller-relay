<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; background: #0b0f14; color: #dfe7ef; }
    header { display:flex; align-items:center; gap:8px; padding:10px 14px; background:#121824; border-bottom:1px solid #20283a; position:sticky; top:0; z-index:1000; flex-wrap:wrap; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; line-height:14px; background:#2a3347; border:1px solid #3a4461; color:#b7c1d6; white-space:nowrap; }
    .pill.ok{ background:#15321f; border-color:#1e6a33; color:#a5e7b9; }
    .pill.warn{ background:#3a2a18; border-color:#b57a28; color:#ffd89a; }
    .pill.bad{ background:#3a1a1a; border-color:#b52828; color:#ff9a9a; }
    #statusRow{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
    #wsUrl{ font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; color:#9fb2d1; }
    main{ display:grid; grid-template-columns:1fr 360px; gap:10px; padding:12px; }
    @media (max-width: 1000px) { main{ grid-template-columns:1fr; } }
    #videoWrap{ position:relative; background:#0f1320; border:1px solid #1d2436; border-radius:8px; overflow:hidden; min-height:360px; }
    #vid{ width:100%; height:auto; display:block; background:#000; }
    #overlay{ position:absolute; inset:0; display:grid; place-items:center; background:linear-gradient(180deg, rgba(10,14,21,0.75), rgba(10,14,21,0.85)); pointer-events:none; }
    #ovText{ font-size:16px; color:#c6d3ea; text-shadow:0 1px 2px rgba(0,0,0,0.6); }
    #controls{ display:flex; flex-wrap:wrap; gap:8px; padding:10px 0; }
    button, input, select { font:inherit; padding:8px 10px; border-radius:6px; border:1px solid #2a3347; background:#172035; color:#dfe7ef; }
    button:hover{ background:#1b2844; border-color:#3a4461; cursor:pointer; }
    input, select{ background:#111829; border-color:#28324a; }
    #sidePanel{ display:grid; grid-template-rows:min-content min-content 1fr min-content; gap:10px; }
    #chatWrap{ border:1px solid #1d2436; border-radius:8px; overflow:hidden; background:#0d1322; min-height:260px; }
    #chatWrap[hidden]{ display:none; }
    #chatIframe{ width:100%; height:260px; border:0; background:#0d1322; }
    #logPanel{ display:grid; grid-template-rows:min-content 1fr; border:1px solid #1d2436; border-radius:8px; overflow:hidden; }
    #logHeader{ display:flex; align-items:center; justify-content:space-between; padding:8px 10px; background:#121824; border-bottom:1px solid #1d2436; }
    #log{ margin:0; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; line-height:1.4; background:#0d1322; white-space:pre; overflow:auto; min-height:260px; }
    footer{ padding:12px 14px; color:#7a8fb2; border-top:1px solid #20283a; background:#0e1524; }
  </style>
</head>
<body>

  <header>
    <div id="statusRow">
      <span id="pRelay" class="pill">Relay</span>
      <span id="pWs" class="pill">WS</span>
      <span id="pHost" class="pill">Host</span>
      <span id="pSig" class="pill">Signaling</span>
      <span id="pIce" class="pill">ICE</span>
      <span id="pDtls" class="pill">DTLS</span>
      <span id="pPc" class="pill">Peer</span>
      <span id="pDc" class="pill">DC</span>
      <span id="pAv" class="pill">A/V</span>
      <span id="pTransport" class="pill">Transport</span>
    </div>
    <span id="wsUrl" class="pill" style="margin-left:auto">ws://</span>
  </header>

  <main>
    <section>
      <div id="videoWrap">
        <video id="vid" playsinline muted></video>
        <div id="overlay">
          <div id="ovText">Waiting for video…</div>
        </div>
      </div>

      <div id="controls">
        <button id="btnUnmute">Unmute</button>
        <button id="btnChat">Toggle chat</button>
        <button id="btnFullscreen">Fullscreen</button>
        <button id="btnDownloadLogs">Download logs</button>
        <input id="chatChannel" type="text" placeholder="Twitch channel" style="min-width:160px" />
        <button id="btnSetChannel">Set chat channel</button>
      </div>

      <section aria-label="Controller remap">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
          <label>Remap from <select id="remapFrom"></select></label>
          <label>to <select id="remapTo"></select></label>
          <button id="btnApplyRemap">Apply remap</button>
        </div>
      </section>
    </section>

    <aside id="sidePanel">
      <div id="chatWrap" hidden>
        <iframe id="chatIframe" title="Twitch chat"></iframe>
      </div>

      <div id="logPanel">
        <div id="logHeader">
          <strong>Viewer logs</strong>
          <span style="opacity:.7">Scroll to view. Use “Download logs” to export.</span>
        </div>
        <pre id="log"></pre>
      </div>
    </aside>
  </main>

  <footer>
    <small>Status indicators reflect last known state and auto-recover triggers.</small>
  </footer>
  <script>
    const vid = document.getElementById('vid');
    const ovText = document.getElementById('ovText');
    const btnUnmute = document.getElementById('btnUnmute');
    const btnChat = document.getElementById('btnChat');
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnDownloadLogs = document.getElementById('btnDownloadLogs');
    const chatWrap = document.getElementById('chatWrap');
    const chatIframe = document.getElementById('chatIframe');
    const wsUrlPill = document.getElementById('wsUrl');
    const remapFrom = document.getElementById('remapFrom');
    const remapTo = document.getElementById('remapTo');
    const btnApplyRemap = document.getElementById('btnApplyRemap');

    const pSig = document.getElementById('pSig');
    const pIce = document.getElementById('pIce');
    const pDtls = document.getElementById('pDtls');
    const pPc = document.getElementById('pPc');
    const pDc = document.getElementById('pDc');
    const pAv = document.getElementById('pAv');
    const pWs = document.getElementById('pWs');
    const pHost = document.getElementById('pHost');
    const pRelay = document.getElementById('pRelay');
    const pTransport = document.getElementById('pTransport');

    const logEl = document.getElementById('log');
    const logBuffer = [];
    function log(msg) {
      const t = new Date().toLocaleTimeString();
      const line = `[${t}] ${msg}`;
      logBuffer.push(line);
      logEl.textContent += line + "\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }
    if (btnDownloadLogs) {
      btnDownloadLogs.addEventListener('click', () => {
        const blob = new Blob([logBuffer.join("\n")], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "viewer_logs.txt";
        a.click();
        URL.revokeObjectURL(url);
      });
    }
    function setPill(pill, cls, text) {
      if (!pill) return;
      pill.classList.remove('ok', 'warn', 'bad');
      if (cls) pill.classList.add(cls);
      if (text) pill.textContent = text;
    }

    const params = new URLSearchParams(window.location.search);
    const pageHost = window.location.host;
    let relayHost = (params.get('relay') || pageHost).replace(/^https?:\/\//, '').replace(/\/+$/, '');
    const wsUrl = `${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${relayHost}/ws/viewer`;
    wsUrlPill.textContent = wsUrl;
    setPill(pRelay, 'ok', `Relay: ${relayHost}`);

    const tproto = (params.get('tproto') || '').toLowerCase();
    if (tproto === 'rtmps') setPill(pTransport, 'ok', 'Transport: WebRTC + RTMPS');
    else if (tproto === 'rtmp') setPill(pTransport, 'ok', 'Transport: WebRTC + RTMP');
    else setPill(pTransport, 'ok', 'Transport: WebRTC');

    const buttonMap = { 0:'A',1:'B',2:'X',3:'Y', 4:'LB',5:'RB',8:'Back',9:'Start', 10:'LS',11:'RS',12:'DPadUp',13:'DPadDown',14:'DPadLeft',15:'DPadRight' };
    let remap = JSON.parse(localStorage.getItem('remapConfig')||'{}');
    Object.values(buttonMap).forEach(b=>{ if(!remap[b]) remap[b]=b; });

    const allButtons = Object.values(buttonMap);
    allButtons.forEach(b=>{
      const o1 = document.createElement('option'); o1.value=b; o1.textContent=b; remapFrom.appendChild(o1);
      const o2 = document.createElement('option'); o2.value=b; o2.textContent=b; remapTo.appendChild(o2);
    });
    btnApplyRemap.addEventListener('click', () => {
      const from = remapFrom.value, to = remapTo.value;
      if (from && to) {
        remap[from] = to;
        localStorage.setItem('remapConfig', JSON.stringify(remap));
        log(`Remap applied: ${from} → ${to}`);
      }
    });

    let pc, ws, dc, viewerID = null;
    let restarting = false;

    function startViewer() {
      log('WS URL → ' + wsUrl);
      setPill(pWs, 'warn', 'WS: connecting');

      pc = new RTCPeerConnection({
        sdpSemantics: 'unified-plan',
        iceServers: [{ urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478'] }],
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      });
      setPill(pSig, 'ok', 'Signaling: ready');

      const inboundStream = new MediaStream();
      const vTrans = pc.addTransceiver('video', { direction: 'recvonly' });
      pc.addTransceiver('audio', { direction: 'recvonly' });

      try {
        const want = (params.get('codec') || '').trim().toLowerCase();
        const caps = RTCRtpReceiver.getCapabilities('video');
        const codecs = (caps.codecs || []);
        const vp8  = codecs.filter(c => (c.mimeType || '').toLowerCase().includes('vp8'));
        const h264 = codecs.filter(c => (c.mimeType || '').toLowerCase().includes('h264'));
        let prefs = [], msg = '';
        if (want === 'vp8')      { prefs = vp8;            msg = 'Codec preference set: force VP8'; }
        else if (want === 'h264'){ prefs = h264;           msg = 'Codec preference set: force H.264'; }
        else                     { prefs = [...vp8, ...h264]; msg = 'Codec preference set: VP8 first, H.264 fallback'; }
        if (vTrans && vTrans.setCodecPreferences && prefs.length) {
          vTrans.setCodecPreferences(prefs);
          log(msg);
        }
      } catch (e) { log('Codec preference error: ' + e); }

      dc = pc.createDataChannel('inputs', { ordered: true });

      pc.ontrack = e => {
        try {
          log('ontrack: kind=' + e.track.kind);
          if (!inboundStream.getTracks().includes(e.track)) inboundStream.addTrack(e.track);
          if (vid.srcObject !== inboundStream) vid.srcObject = inboundStream;
          setPill(pAv, 'ok', 'A/V: attached');
          vid.muted = true;
          vid.addEventListener('loadedmetadata', () => {
            vid.play().then(()=>log('Autoplay started')).catch(err=>log('Autoplay error: '+err));
          }, { once: true });
        } catch (err) { log('ontrack error: ' + err); }
      };

      dc.onopen  = () => { log('DC open');  setPill(pDc, 'ok', 'DC: open'); };
      dc.onclose = () => { log('DC closed'); setPill(pDc, 'bad', 'DC: closed'); };

      pc.oniceconnectionstatechange = () => {
        const s = pc.iceConnectionState;
        log('ICE ' + s);
        setPill(pIce, (s==='connected'||s==='completed')?'ok':(s==='failed'||s==='disconnected')?'bad':'warn', `ICE: ${s}`);
        if (s === 'failed' || s === 'disconnected') restartSession();
      };

      pc.onconnectionstatechange = () => {
        const s = pc.connectionState;
        log('Conn ' + s);
        const cls = s==='connected'?'ok':(s==='connecting'?'warn':'bad');
        setPill(pDtls, cls, `DTLS: ${s}`); setPill(pPc, cls, `Peer: ${s}`);
        if (s === 'failed' || s === 'disconnected' || s === 'closed') restartSession();
      };

      pc.onicecandidate = ev => {
        if (ev.candidate && viewerID && ws?.readyState === 1) {
          ws.send(JSON.stringify({ type:'candidate', viewer:viewerID, candidate:{
            candidate: ev.candidate.candidate, sdpMid: ev.candidate.sdpMid, sdpMLineIndex: ev.candidate.sdpMLineIndex
          }}));
          log('Sent ICE candidate');
        }
      };

      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        log('WS open'); setPill(pWs, 'ok', 'WS: open');
        ws.send(JSON.stringify({ type:'hello', role:'viewer' }));
      };
      ws.onerror = err => { log('WebSocket error: ' + (err.message || JSON.stringify(err))); setPill(pWs,'bad','WS: error'); restartSession(); };
      ws.onclose = () => { log('WS closed'); setPill(pWs,'bad','WS: closed'); restartSession(); };
      ws.onmessage = async evt => {
        const msg = JSON.parse(evt.data);
        if (msg.type === 'pong') return;
        if (msg.type === 'welcome') {
          viewerID = msg.viewer_id;
          log('Welcome ' + viewerID);
          setPill(pHost, 'ok', 'Host: ready');
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ type:'offer', role:'viewer', viewer:viewerID, sdp:{ type:offer.type, sdp:offer.sdp } }));
          setPill(pSig, 'warn', 'Signaling: offer sent');
        } else if (msg.type === 'answer') {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          log('Answer applied'); setPill(pSig, 'ok', 'Signaling: answer');
        } else if (msg.type === 'candidate') {
          try { await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); log('Candidate added'); }
          catch (e) { log('ICE add error ' + e.message); }
        }
      };

      setInterval(() => {
        if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type:'ping', viewer:viewerID }));
        if (dc && dc.readyState === 'open') dc.send(JSON.stringify({ type:'ping', viewer:viewerID }));
      }, 12000);
    }

    function stopSession(){ try{dc?.close()}catch{} try{ws?.close()}catch{} try{pc?.close()}catch{} vid.srcObject=null; dc=ws=pc=null; }
    function restartSession(){ if(restarting) return; restarting=true; stopSession(); setTimeout(()=>{ restarting=false; startViewer(); }, 800); }

    let lastFrameTime = Date.now();
    vid.addEventListener('playing', () => { lastFrameTime = Date.now(); });
    setInterval(() => {
      if (vid.srcObject) {
        const t = vid.currentTime;
        if (t && t !== 0) lastFrameTime = Date.now();
        if (Date.now() - lastFrameTime > 2000) { // relax threshold to avoid premature restarts
          log('No frames for >2000ms — restarting session to recover');
          restartSession(); lastFrameTime = Date.now();
        }
      }
    }, 600);
    let lastT = 0;
    setInterval(() => {
      if (vid.srcObject) {
        const t = vid.currentTime;
        if (t && t !== lastT) { setPill(pAv, 'ok', 'A/V: frames'); lastT = t; }
        else { setPill(pAv, 'warn', 'A/V: stalled'); }
      }
    }, 1000);

    startViewer();
  </script>
</body>
</html>
